[{
    "title": "R包caret基本功能【1】——六种基本功能",
    "date": "",
    "description": "介绍机器学习R包caret。 last update：2022-02-24",
    "body": "介绍机器学习R包。\n1. 数据分割 基于输出变量的分割 在建模之前，需要对样本数据进行分割分为训练集和测试集。在之前建模过程中，我发现我使用sample进行分割存在一定的问题，比如我分割出来的数据中response的占比在训练集和测试集中差别很大等等。caret包中可以解决这个问题，通过设置p值，同时确定训练集和测试集的占比，并各个因子水平下取占比（表述的有点问题）。\ncreateDataPartition(y, times = 1, p = 0.5, list = TRUE, groups = min(5, length(y))) 2. 预处理 2.1 虚拟变量处理 数据预处理又包括：对因子型变量进行虚拟变量处理（比如response在数据中是yes或no的形式表示，那么可以在这一步转换为虚拟变量0,1，这一步骤尤其适合多个因子型变量都需要处理的情况，可以节约时间）；\ncaret包假定所有的数据都是数值型的，比如因子型的可以通过model.matrix和dummyVars转换为dummy的变量。 dummyVars：\ndummyVars(formula, data, sep = \u0026quot;.\u0026quot;, levelsOnly = FALSE, fullRank = FALSE, ...) predict(object, newdata, na.action = na.pass, ...) formula：y~x1+x2，公式右边需要处理为哑变量的因子型变量，不确定哪些是因子型变量的话，可以直接使用y~.来制定所有的列，自动把因子型变量的进行处理。\n2.2 近零方差变量的删除 比如有些变量存在一些很特殊的值，这些值的占比很少，假设response中yes的为99个，no的为1个，那么一些模型来说，模型会崩溃(crash)或者fit to be unstable. 当数据做交叉验证时进行分割以及bootstrap采样的时候，这些变量可能是零方差的，举个例子：\ndata(mdrr) data.frame(table(mdrrDescr$nR11)) ## Var1 Freq ## 1 0 501 ## 2 1 4 ## 3 2 23 当存在很多变量时，可以用过这个函数批量处理：\nnearZeroVar(x, freqCut = 95/5, uniqueCut = 10, saveMetrics = FALSE, names = FALSE, foreach = FALSE, allowParallel = TRUE) nzv(x, freqCut = 95/5, uniqueCut = 10, saveMetrics = FALSE, names = FALSE) freqCut：阈值，默认值是最频繁的数值个数95/次频繁的数值个数5\n2.3 删除高相关的预测变量和完全线性关系的变量 2.4 数据标准化处理 2.5 缺失数据的处理 2.6 变量转换 3. 特征选择 4. 使用重采样的模型调整 5. 变量重要性的评估 参考资料：  教你使用caret包(一)\u0026ndash;数据预处理  ",
    "ref": "/blog/2022-2-24_caret1/"
  },{
    "title": "R包mlr3基本功能【1】——R6类——需要修订",
    "date": "",
    "description": "介绍机器学习R包caret。 last update：2022-02-24",
    "body": "介绍机器学习R包mlr3，该包提供了分类、回归、生存分析以及其他的机器学习任务，包含超参的调节以及特征的选择，本地支持很多操作的并行化。\n1. mlr3 Quickstart install.packages(\u0026#34;mlr3\u0026#34;) 对iris数据集的前120行训练一个决策树，并且对后30行进行最终的预测，最后判断预测模型的准确性。\nlibrary(\u0026#34;mlr3\u0026#34;) task = tsk(\u0026#34;iris\u0026#34;) learner = lrn(\u0026#34;classif.rpart\u0026#34;) # train a model of this learner for a subset of the task learner$train(task, row_ids = 1:120) # this is what the decision tree looks like learner$model 预测\npredictions = learner$predict(task, row_ids = 121:150) predictions 准确性\n# accuracy of our model on the test set of the final 30 rows predictions$score(msr(\u0026#34;classif.acc\u0026#34;))   2. R6 mlr3提供的所有基本构建块都是R6类，因此需要了解一下R6类。R6是R用于面向对象编程(OO)的语言之一，面向对象是以功能来划分问题，而不是步骤。\n  object是通过R6::R6Class()创建的，foo = Foo$new(bar = 1)就是创建了一个新的Foo类的object，设定bar这个参数值为1，在mlr3中很多object都是通过特殊的功能来创建的。e.g. lrn(\u0026quot;regr.rpart\u0026quot;)。\n  object有沉默状态，可以通过$来调用，比如我们可以通过 foo$bar调取foo变量中的bar参数值或者重新对参数值进行设定。\n  object还公开了一些方法来检查object的状态，检索信息或执行改变对象内部状态的操作，比如$train通过建立和存储一个训练过的模型来改变学习者的内部状态，以便在给定数据的情况下使用该模型进行预测。\n  object有公开和私密的field和方法，公开的field和方法定义了和object联系的API，私密的方法只和使用者有关。（？？？）\n  拷贝object可以使用$clone()方法以及对nested object使用deep=TRUE参数，比如foo2 = foo$clone(deep = TRUE)\n  更多关于R6的介绍可以看R6介绍，特别是其中introduction部分。\n2.1 R6基础介绍 创建一个简单的R6类，public参数是项目列表，可以是函数和filed（非函数），函数可以被当作方法使用。\nlibrary(R6) Person \u0026lt;- R6Class(\u0026#34;Person\u0026#34;, public = list( name = NULL, hair = NULL, initialize = function(name = NA, hair = NA) { self$name \u0026lt;- name self$hair \u0026lt;- hair self$greet() }, set_hair = function(val) { self$hair \u0026lt;- val }, greet = function() { cat(paste0(\u0026#34;Hello, my name is \u0026#34;, self$name, \u0026#34;.\\n\u0026#34;)) } ) ) 要实例化这个类的一个对象，使用$new():\nann \u0026lt;- Person$new(\u0026#34;Ann\u0026#34;, \u0026#34;black\u0026#34;) ann $new()方法创建了对象并且使用了initialize()方法（如果存在的话）。在class方法里，self指的是对象，对象中面向公众的成员可以通过self$x来使用，赋值通过self$x \u0026lt;- y完成。一旦对象被实例化，就可以通过$来获取值和方法。\nann$hair ann$greet() ann$set_hair(\u0026#34;red\u0026#34;) ann$hair 2.2 R6的私密成员 在上面的例子中，所有的成员都是公开的，但也可以在对象中添加私密成员：\nQueue \u0026lt;- R6Class(\u0026#34;Queue\u0026#34;, public = list( initialize = function(...) { for (item in list(...)) { self$add(item) } }, add = function(x) { private$queue \u0026lt;- c(private$queue, list(x)) invisible(self) }, remove = function() { if (private$length() == 0) return(NULL) # Can use private$queue for explicit access head \u0026lt;- private$queue[[1]] private$queue \u0026lt;- private$queue[-1] head } ), private = list( queue = list(), length = function() base::length(private$queue) ) ) q \u0026lt;- Queue$new(5, 6, \u0026#34;foo\u0026#34;) 公共的成员可以通过self来获取，比如self$add()，私密的成员可以通过private来获取，比如private$queue，公共的成员使用方法如下：\n# Add and remove items q$add(\u0026#34;something\u0026#34;) q$add(\u0026#34;another thing\u0026#34;) q$remove() #\u0026gt; [1] 5 q$remove() #\u0026gt; [1] 6 q$remove() #\u0026gt; [1] \u0026#34;foo\u0026#34; q$remove() #\u0026gt; [1] \u0026#34;something\u0026#34; q$remove() #\u0026gt; [1] \u0026#34;another thing\u0026#34; 但是私密的成员没办法直接获取。\nq$queue #\u0026gt; NULL q$length() #\u0026gt; Error: attempt to apply non-function 这样的设计可以使得方法连接使用，因为可以让方法在可能的情况下返回self（不可见的）。\nq$add(10)$add(11)$add(12) 2.3 Active bindings Active bindings看起来像fields，但是每次获取时，会调用一个函数，通常是公开可见的。\nNumbers \u0026lt;- R6Class(\u0026#34;Numbers\u0026#34;, public = list( x = 100 ), active = list( x2 = function(value) { if (missing(value)) return(self$x * 2) else self$x \u0026lt;- value/2 }, rand = function() rnorm(1) ) ) n \u0026lt;- Numbers$new() n$x 当以读取值的方式访问active binding时，它会调用value的函数作为缺少的参数:\nn$x2 #\u0026gt; [1] 200 当它像赋值一样被访问时，它使用赋值值作为value参数:\nn$x2 \u0026lt;- 1000 n$x #\u0026gt; [1] 500 如果函数没有参数，那么不能使用赋值符号：\nn$rand #\u0026gt; [1] 0.2648 n$rand #\u0026gt; [1] 2.171 n$rand \u0026lt;- 3 #\u0026gt; Error: unused argument (quote(3)) 2.4 继承 一个R6类可以继承另外一个R6类，也就是有超类和亚类。亚类可以有另外的方法，而且可以有覆盖超类的方法，举个例子，queue保留它的历史，添加show()方法，覆盖remove()方法：\n# Note that this isn\u0026#39;t very efficient - it\u0026#39;s just for illustrating inheritance. HistoryQueue \u0026lt;- R6Class(\u0026#34;HistoryQueue\u0026#34;, inherit = Queue, public = list( show = function() { cat(\u0026#34;Next item is at index\u0026#34;, private$head_idx + 1, \u0026#34;\\n\u0026#34;) for (i in seq_along(private$queue)) { cat(i, \u0026#34;: \u0026#34;, private$queue[[i]], \u0026#34;\\n\u0026#34;, sep = \u0026#34;\u0026#34;) } }, remove = function() { if (private$length() - private$head_idx == 0) return(NULL) private$head_idx \u0026lt;- private$head_idx + 1 private$queue[[private$head_idx]] } ), private = list( head_idx = 0 ) ) hq \u0026lt;- HistoryQueue$new(5, 6, \u0026#34;foo\u0026#34;) hq$show() #\u0026gt; Next item is at index 1  #\u0026gt; 1: 5 #\u0026gt; 2: 6 #\u0026gt; 3: foo hq$remove() #\u0026gt; [1] 5 hq$show() #\u0026gt; Next item is at index 2  #\u0026gt; 1: 5 #\u0026gt; 2: 6 #\u0026gt; 3: foo hq$remove() #\u0026gt; [1] 6 亚类的方法可以称之为super$xx()，CountingQueue（接下来的例子）持续计算曾经加在queue里的object的总数，它覆盖了add()方法——它增加一个计数器，然后用超$add(x)调用超类的add()方法：\nCountingQueue \u0026lt;- R6Class(\u0026#34;CountingQueue\u0026#34;, inherit = Queue, public = list( add = function(x) { private$total \u0026lt;- private$total + 1 super$add(x) }, get_total = function() private$total ), private = list( total = 0 ) ) cq \u0026lt;- CountingQueue$new(\u0026#34;x\u0026#34;, \u0026#34;y\u0026#34;) cq$get_total() #\u0026gt; [1] 2 cq$add(\u0026#34;z\u0026#34;) cq$remove() #\u0026gt; [1] \u0026#34;x\u0026#34; cq$remove() #\u0026gt; [1] \u0026#34;y\u0026#34; cq$get_total() #\u0026gt; [1] 3 2.5 包括参考object的field 如果你的R6类包含任何具有引用语义的字段(例如，其他R6对象，环境)，这些字段应该在initialize方法中填充。如果该字段在类定义中直接设置为引用对象，则该对象将在R6对象的所有实例中共享。这里有一个例子:\nSimpleClass \u0026lt;- R6Class(\u0026#34;SimpleClass\u0026#34;, public = list(x = NULL) ) SharedField \u0026lt;- R6Class(\u0026#34;SharedField\u0026#34;, public = list( e = SimpleClass$new() ) ) s1 \u0026lt;- SharedField$new() s1$e$x \u0026lt;- 1 s2 \u0026lt;- SharedField$new() s2$e$x \u0026lt;- 2 # 改变 s2$e$x 也会改变 s1$e$x 的值 s1$e$x #\u0026gt; [1] 2 为了避免上面出现的同时改变的情况，请填充initialize方法中的字段:\nNonSharedField \u0026lt;- R6Class(\u0026#34;NonSharedField\u0026#34;, public = list( e = NULL, initialize = function() self$e \u0026lt;- SimpleClass$new() ) ) n1 \u0026lt;- NonSharedField$new() n1$e$x \u0026lt;- 1 n2 \u0026lt;- NonSharedField$new() n2$e$x \u0026lt;- 2 # n2$e$x 不会影响 n1$e$x 的值 n1$e$x #\u0026gt; [1] 1 2.6 在已有的类中添加成员 在已有的类中添加成员是一个很有用的操作，可以在generator对象中使用$set()方法来完成。\nSimple \u0026lt;- R6Class(\u0026#34;Simple\u0026#34;, public = list( x = 1, getx = function() self$x ) ) Simple$set(\u0026#34;public\u0026#34;, \u0026#34;getx2\u0026#34;, function() self$x*2) # To replace an existing member, use overwrite=TRUE Simple$set(\u0026#34;public\u0026#34;, \u0026#34;x\u0026#34;, 10, overwrite = TRUE) s \u0026lt;- Simple$new() s$x #\u0026gt; [1] 10 s$getx2() #\u0026gt; [1] 20 $set()中第一个输入表示public的成员，第二个输入表示新增加的函数名称/成员为x，第三个是增加的函数/用新的值覆盖原先的x值。为了防止修改类，可以在创建类时使用lock_class=TRUE。也可以按照如下方式锁定和解锁一个类:\n# Create a locked class Simple \u0026lt;- R6Class(\u0026#34;Simple\u0026#34;, public = list( x = 1, getx = function() self$x ), lock_class = TRUE ) # This would result in an error # Simple$set(\u0026#34;public\u0026#34;, \u0026#34;y\u0026#34;, 2) # Unlock the class Simple$unlock() # Now it works Simple$set(\u0026#34;public\u0026#34;, \u0026#34;y\u0026#34;, 2) # Lock the class again Simple$lock() 2.7 克隆对象 默认的，R6对象存在clone方法来克隆对象。\nSimple \u0026lt;- R6Class(\u0026#34;Simple\u0026#34;, public = list( x = 1, getx = function() self$x ) ) s \u0026lt;- Simple$new() # Create a clone s1 \u0026lt;- s$clone() # Modify it s1$x \u0026lt;- 2 s1$getx() #\u0026gt; [1] 2 # Original is unaffected by changes to the clone s$getx() #\u0026gt; [1] 1 如果不希望添加克隆方法，可以在创建类时使用cloneable=FALSE。如果任何加载的R6对象有一个克隆方法，该函数将使用83,552字节，但是对于每个额外的对象，克隆方法只消耗少量的空间(112字节)。\n2.8 深层克隆 如果有任何字段是具有引用语义的对象(environments、R6对象、引用类对象)，则副本将获得对同一对象的引用。这有时是可取的，但通常不是。\n例如，我们将创建一个对象c1，其中包含另一个R6对象s，然后克隆它。因为原始的和克隆的s字段都指向同一个对象，所以从一个字段修改它会导致另一个字段的变化。\nSimple \u0026lt;- R6Class(\u0026#34;Simple\u0026#34;, public = list(x = 1)) Cloneable \u0026lt;- R6Class(\u0026#34;Cloneable\u0026#34;, public = list( s = NULL, initialize = function() self$s \u0026lt;- Simple$new() ) ) c1 \u0026lt;- Cloneable$new() c2 \u0026lt;- c1$clone() # Change c1\u0026#39;s `s` field c1$s$x \u0026lt;- 2 # c2\u0026#39;s `s` is the same object, so it reflects the change c2$s$x #\u0026gt; [1] 2 可以发现更改c1后c2也同时发生了改变，我们可以使用deep=TRUE选项来让克隆对象接收到s的拷贝:\nc3 \u0026lt;- c1$clone(deep = TRUE) # Change c1\u0026#39;s `s` field c1$s$x \u0026lt;- 3 # c2\u0026#39;s `s` is different c3$s$x #\u0026gt; [1] 2 此时c3并不会改变，克隆的默认行为(deep=TRUE)是复制R6对象的字段，但不复制环境、引用类对象或其他包含其他引用类型对象的数据结构(例如，带有R6对象的列表)的字段。\n如果R6对象包含这些类型的对象，并且希望对它们进行深度克隆，则必须在名为deep_clone的私有方法中提供用于深度克隆的自己的函数。下面是一个R6对象的例子，它有两个字段，a和b，都是环境，都包含一个值x。它还有一个字段v，它是一个常规(非引用)值，和一个私有的deep_clone方法。\nCloneEnv \u0026lt;- R6Class(\u0026#34;CloneEnv\u0026#34;, public = list( a = NULL, b = NULL, v = 1, initialize = function() { self$a \u0026lt;- new.env(parent = emptyenv()) self$b \u0026lt;- new.env(parent = emptyenv()) self$a$x \u0026lt;- 1 self$b$x \u0026lt;- 1 } ), private = list( deep_clone = function(name, value) { # With x$clone(deep=TRUE) is called, the deep_clone gets invoked once for # each field, with the name and value. if (name == \u0026#34;a\u0026#34;) { # `a` is an environment, so use this quick way of copying list2env(as.list.environment(value, all.names = TRUE), parent = emptyenv()) } else { # For all other fields, just return the value value } } ) ) c1 \u0026lt;- CloneEnv$new() c2 \u0026lt;- c1$clone(deep = TRUE) 当c1$clone(deep=TRUE)被调用时，c1中的每个字段都会被调用deep_clone方法，并传递字段的名称和值。在我们的版本中，a环境被复制，但b没有，v也没有(但这没关系，因为v不是一个引用对象)。我们可以测试克隆:\n# Modifying c1$a doesn\u0026#39;t affect c2$a, because they\u0026#39;re separate objects c1$a$x \u0026lt;- 2 c2$a$x #\u0026gt; [1] 1 # Modifying c1$b does affect c2$b, because they\u0026#39;re the same object c1$b$x \u0026lt;- 3 c2$b$x #\u0026gt; [1] 3 # Modifying c1$v doesn\u0026#39;t affect c2$v, because they\u0026#39;re not reference objects c1$v \u0026lt;- 4 c2$v #\u0026gt; [1] 1 在上面的deep_clone方法示例中，我们检查了每个字段的名称，以确定如何处理它，但我们也可以通过使用继承(value，“R6”)或is.environment()等来检查值。\n2.9 在环境中打印R6对象 R6对象有一个默认的打印方法，该方法列出了对象的所有成员。如果类定义了打印方法，那么它将覆盖默认方法。\nPrettyCountingQueue \u0026lt;- R6Class(\u0026#34;PrettyCountingQueue\u0026#34;, inherit = CountingQueue, public = list( print = function(...) { cat(\u0026#34;\u0026lt;PrettyCountingQueue\u0026gt; of \u0026#34;, self$get_total(), \u0026#34; elements\\n\u0026#34;, sep = \u0026#34;\u0026#34;) } ) ) pq \u0026lt;- PrettyCountingQueue$new(1, 2, \u0026#34;foobar\u0026#34;) pq #\u0026gt; \u0026lt;PrettyCountingQueue\u0026gt; of 3 elements 2.10 终结器 有时候，在对象被垃圾回收时运行一个函数是很有用的。例如，您可能希望确保关闭文件或数据库连接。为此，您可以定义一个私有finalize()方法，当对象被垃圾收集时，将不带参数调用该方法。\nA \u0026lt;- R6Class(\u0026#34;A\u0026#34;, private = list( finalize = function() { print(\u0026#34;Finalizer has been called!\u0026#34;) } )) # Instantiate an object: obj \u0026lt;- A$new() # Remove the single existing reference to it, and force garbage collection # (normally garbage collection will happen automatically from time # to time) rm(obj); gc() #\u0026gt; [1] \u0026#34;Finalizer has been called!\u0026#34; #\u0026gt; used (Mb) gc trigger (Mb) max used (Mb) #\u0026gt; Ncells 678820 36.3 1349101 72.1 1349101 72.1 #\u0026gt; Vcells 1273761 9.8 8388608 64.0 3247078 24.8 2.11 类方法和成员函数 当R6类定义包含函数时，这些函数都是class方法：可以通过self来调用，当R6对象被拷贝时，最终的对象将会有一个self来指代新的对象，这是通过改变克隆对象中方法的封闭环境来实现的。\n相比较class method，我们可以在R6对象中添加常规的函数做为成员，可以通过在initialize方法中把方法分配到filed，或者在对象被实例化之后，这些函数不是class methodm，也无法通过self，private或super来接触到。\n下面是一个简单的类，它有一个方法get_self()，它只返回self，还有一个空成员fn。在这个例子中，我们将赋予fn一个函数，它具有与get_self相同的函数体。然而，由于它是一个常规函数，self将引用R6对象以外的东西:\nFunctionWrapper \u0026lt;- R6Class(\u0026#34;FunctionWrapper\u0026#34;, public = list( get_self = function() { self }, fn = NULL ) ) a \u0026lt;- FunctionWrapper$new() # Create a function that accesses a variable named `self`. # Note that `self` in this function\u0026#39;s scope refers to 100, not to the R6 object. self \u0026lt;- 100 a$fn \u0026lt;- function() { self } a$get_self() #\u0026gt; \u0026lt;FunctionWrapper\u0026gt; #\u0026gt; Public: #\u0026gt; clone: function (deep = FALSE) #\u0026gt; fn: function () #\u0026gt; get_self: function () a$fn() #\u0026gt; [1] 100 从R6 2.3.0开始，如果对象被克隆，成员(非方法)函数的外部环境将不会改变，这是人们通常所期望的。它会这样表现:\nb \u0026lt;- a$clone() b$get_self() #\u0026gt; \u0026lt;FunctionWrapper\u0026gt; #\u0026gt; Public: #\u0026gt; clone: function (deep = FALSE) #\u0026gt; fn: function () #\u0026gt; get_self: function () b$fn() #\u0026gt; [1] 100 3. S3 参考资料：   2分钟让你明白什么是面向对象编程\n  mlr3 book\n  ",
    "ref": "/blog/2022-2-24_mlr31/"
  },{
    "title": "R包开发【2】——编写函数",
    "date": "",
    "description": "介绍如何开发R包。 last update：2022-02-23",
    "body": "R包功能的实现需要各种函数，函数应该如何编写？什么样的步骤可以被包括在函数里？函数需要哪些基本的功能？函数应该如何命名？函数可以通过调用函数并且给定参数来代替对代码的重复操作（当一个操作需要重复2次时），通过自定义的函数命名来使得功能易懂，并且方便后续的更新和更改，对功能进行更改只需要变更函数，而非在所有的代码中一一修改。\n1. 基本步骤 写函数的基本步骤如下：\n1.1 函数命名   命名要尽量短，而且指示函数的功能，长一点能够清楚的展示功能也无妨。\n  函数名尽可能是动词，不过相比使用get、compute、calculate、 determine这样宽泛的动词来说，名词相对更好，函数的参数尽可能是名词。想到好的名字随时去更改掉它。\n  当函数名包含很多单词时，可以统一选取一种使用，可以使用snake_case，或者camelCase的形式，两者不要混着用。\n  同类的功能名称保持一定的一致性。\n  # Good input_select() input_checkbox() input_text() # Not so good select_input() checkbox_input()   尽量避免和已有的函数名称重复，尤其是基本包里的。\n  习惯使用注释把文件分割，快捷键是：cmd/ctrl + shift + R\n  # Load data -------------------------------------- # Plot data -------------------------------------- 1.2 列出输入数据或参数 1.3 函数内部功能 我觉得还需要加上一个步骤就是，确定函数的输出是什么。写完函数还需要对函数进行交互式测试，参考这本书的测试章节。通过下面的简化过程比较容易理解：\n初始未简化：\ndf \u0026lt;- tibble::tibble( a = rnorm(10), b = rnorm(10), c = rnorm(10), d = rnorm(10) ) df$a \u0026lt;- (df$a - min(df$a, na.rm = TRUE)) / (max(df$a, na.rm = TRUE) - min(df$a, na.rm = TRUE)) df$b \u0026lt;- (df$b - min(df$b, na.rm = TRUE)) / (max(df$b, na.rm = TRUE) - min(df$a, na.rm = TRUE)) df$c \u0026lt;- (df$c - min(df$c, na.rm = TRUE)) / (max(df$c, na.rm = TRUE) - min(df$c, na.rm = TRUE)) df$d \u0026lt;- (df$d - min(df$d, na.rm = TRUE)) / (max(df$d, na.rm = TRUE) - min(df$d, na.rm = TRUE)) 编写函数进行简化：\nrescale01 \u0026lt;- function(x) { rng \u0026lt;- range(x, na.rm = TRUE) (x - rng[1]) / (rng[2] - rng[1]) } df$a \u0026lt;- rescale01(df$a) df$b \u0026lt;- rescale01(df$b) df$c \u0026lt;- rescale01(df$c) df$d \u0026lt;- rescale01(df$d) 目前仍存在重复的步骤，可以通过向量和迭代的使用来简化，并进一步修改函数：\nx \u0026lt;- c(1:10, Inf) rescale01 \u0026lt;- function(x) { rng \u0026lt;- range(x, na.rm = TRUE, finite = TRUE) (x - rng[1]) / (rng[2] - rng[1]) } rescale01(x) #\u0026gt; [1] 0.0000000 0.1111111 0.2222222 0.3333333 0.4444444 0.5555556 0.6666667 #\u0026gt; [8] 0.7777778 0.8888889 1.0000000 Inf 1.4 返回值  函数返回值的位置  函数默认返回最后一步的状态值，但是可以在运行过程中return()来返回目标数值，比如input是空的情况下，可以立刻返回0等等，另外一种情况是：\nf \u0026lt;- function(){ if (x){ # complicated condition }else{ # simple result } } 当各种条件不能够满足，应该把简单的结果摆在前面提前返回值，就不需要做那么多的条件判断。\n 可管道操作的函数  最基础的两个管道函数类型是：transformation和side-effect，前者将对象传递给函数的第一个参数，并返回修改后的对象，后者传递的对象不会被转换，该函数对对象执行一个操作，后者不可见的返回第一个参数，这样即使没有输出也可以在管道中使用。举个例子：\nshow_missings \u0026lt;- function(df) { n \u0026lt;- sum(is.na(df)) cat(\u0026#34;Missing values: \u0026#34;, n, \u0026#34;\\n\u0026#34;, sep = \u0026#34;\u0026#34;) invisible(df) } show_missings(mtcars) #\u0026gt; Missing values: 0 x \u0026lt;- show_missings(mtcars) #\u0026gt; Missing values: 0 class(x) #\u0026gt; [1] \u0026#34;data.frame\u0026#34; dim(x) #\u0026gt; [1] 32 11 mtcars %\u0026gt;% show_missings() %\u0026gt;% mutate(mpg = ifelse(mpg \u0026lt; 20, NA, mpg)) %\u0026gt;% show_missings() #\u0026gt; Missing values: 0 #\u0026gt; Missing values: 18 2. 具体细节 2.1 条件执行   条件必须是逻辑值，如果是向量，需要给出warning，如果是NA，需要报错。\n  可以使用||和\u0026amp;\u0026amp;组合多个逻辑表达式，不要在if语句中使用|或\u0026amp;，这些是适用于多个值的向量化操作，如果确实存在逻辑向量的话，可以使用any或者all来将其折叠为单个值。==也是向量化的，容易得到多个输出，要么检查长度为1，使用all或any折叠，要么使用非向量化的identical，identical非常严格，总是返回单个的TRUE或这单个的FALSE，并且不强制类型，因此在比较整数和双精度浮点数时要小心。\n  identical(0L, 0) #\u0026gt; [1] FALSE x \u0026lt;- sqrt(2) ^ 2 x #\u0026gt; [1] 2 x == 2 #\u0026gt; [1] FALSE x - 2 #\u0026gt; [1] 4.440892e-16 上述可以使用dplyr::near()进行比较，x == NA没有任何用。\n 多个条件时，当条件很多不停的写if的时候，最好重新写，可以使用switch()，能够根据位置或者名称来计算所选的代码（？？？），以及cut()函数来消除if语句的长度，可以用于离散的变量。  2.2 代码风格 多行输写除非很短。\n2.3 函数参数   参数分为两个部分，一个是支持什么样的数据，另外一个是计算的细节。后者通常会有最常使用的默认值。\n  参数的命名\n  参数的命名也很重要，命名较长且应该尽量详细，常用命名如下：\n  x,y,z：向量\n  w：向量的权重\n  df：数据框\n  i,j：行或者列的数字指标\n  n：行的长度或行的个数\n  p：列的个数\n  2.4 检查数值 当写了很多函数的时候，很容易因为忘记函数的使用方法而用无效的输入来调用函数。需要使用提示语句来对输入进行约束。只在关键的几个地方写就可以了，没必要检查每一个，好的举例：\nwt_mean \u0026lt;- function(x, w) { if (length(x) != length(w)) { stop(\u0026#34;`x` and `w` must be the same length\u0026#34;, call. = FALSE) } sum(w * x) / sum(w) } 另外可以使用内置的stopifnot()来检查每个参数是否为TRUE，如果不是那么生成一个错误的消息。\nwt_mean \u0026lt;- function(x, w, na.rm = FALSE) { stopifnot(is.logical(na.rm), length(na.rm) == 1) stopifnot(length(x) == length(w)) if (na.rm) { miss \u0026lt;- is.na(x) | is.na(w) x \u0026lt;- x[!miss] w \u0026lt;- w[!miss] } sum(w * x) / sum(w) } wt_mean(1:6, 6:1, na.rm = \u0026#34;foo\u0026#34;) #\u0026gt; Error in wt_mean(1:6, 6:1, na.rm = \u0026#34;foo\u0026#34;): is.logical(na.rm) is not TRUE 2.5 \u0026hellip; R里面的很多函数不限制输入的参数个数，\u0026hellip;可以捕捉任何就算没有匹配的参数，并且把这些参数传输到另外的函数中使用，尤其适用一个函数包装另外一个函数的情况，缺点是不会对拼写错误的参数报错。\ncommas \u0026lt;- function(...) stringr::str_c(..., collapse = \u0026#34;, \u0026#34;) commas(letters[1:10]) #\u0026gt; [1] \u0026#34;a, b, c, d, e, f, g, h, i, j\u0026#34; 想要捕捉\u0026hellip;的数值，可以使用list(\u0026hellip;)\n2.6 lazy evaluation R中的参数是延迟计算的：直到被需要才会计算，如果使用不到那么不会调用，这是R编程的一个重要属性。\n参考资料：  r4ds  ",
    "ref": "/blog/2022-2-23_function/"
  },{
    "title": "R包开发【3】——R包开发细节",
    "date": "",
    "description": "介绍如何开发R包。 last update：2022-02-23",
    "body": "R包开发的各种细节。\n1. 命名   尽量避免同时使用大小写字母\n  使用该包测试命名是否能用（？？？）。\n  library(available) available(\u0026quot;doofus\u0026quot;) 2. 依赖包 在DESCRIPTION中对依赖包进行注释：\nImports: randomForest, stats 在函数中使用依赖包中的函数时，需要标注pkg::fun。\n 是在roxygen注释中添加@import pkg。这种方法会在R包的NAMESPACE文件中添加import域，在加载R包时，第三方包的所有函数都会被导入。在使用函数时必须用pkg::fun的方法，以防函数名冲突。第二种方法，是在roxygen注释中添加@importFrom pkg fun。这种方法会在NAMESPACE文件中添加importFrom域，在使用时可以直接使用函数名，就像在.GlobalEnv中创建的函数一样。这里推荐第二种引用方法，因为可以大幅减少函数冲突。\n 参考资料：  r4ds  ",
    "ref": "/blog/2022-2-23_rpkg2/"
  },{
    "title": "R包开发【1】——基本流程",
    "date": "",
    "description": "介绍如何开发R包。 last update：2022-02-22",
    "body": "任何可以被自动化的，都应该让它自动化，给自己省时间，也可以方便任何人使用。devtools的目的是使得开发工具变得容易，囊括了多个包来支持开发的各个功能。\n前言：R包开发书籍的基本内容   第二章 示例包\n  第三章 为包开发准备系统\n  第四章 包的基本结构，不同的状态下结构不同（？）\n  第五章 回顾核心的工作流程，介绍核心工具之间的联系：devtools和usethis，Rstudio\n  其余章节 开发细节\n  通过示例入门 1. 在制定路径下新建R包，创建了新的项目 先安装一些包\ninstall.packages(c(\u0026quot;devtools\u0026quot;, \u0026quot;roxygen2\u0026quot;, \u0026quot;testthat\u0026quot;, \u0026quot;knitr\u0026quot;)) library(usethis) create_package(\u0026quot;/Volumes/home /project/Immarker\u0026quot;) 目录下有这些文件\n    .Rbuildignore\n  .Rproj.user\n  DESCRIPTION 文档说明\n  NAMESPACE 列出了外部和内部使用到的函数\n  The R/ directory\n  Immarker.Rproj 不使用Rstudio的话这个可以在创建时，使用参数rstudio = FALSE去除\n  2. 目前创建的目录是一个R包以及RStudio的项目，现在我们再将其增添为Git仓库。 library(devtools) use_git() 3. 写第一个函数 根据自己的需求写函数，这本书不涉及到函数应该如何写，但是可以参考Functions chapter of R for Data Science and the Functions chapter of Advanced R.\n举个例子：\nstrsplit1 \u0026lt;- function(x, split) { strsplit(x, split = split)[[1]] } 4. 定义R函数 把R函数保存在R文件中，存放在R目录下。\n\u0026gt; use_r(\u0026quot;strsplit1\u0026quot;) ✓ Setting active project to '/Volumes/home /project/Immarker' • Modify 'R/strsplit1.R' • Call `use_test()` to create a matching test file 只在这个文件中写入函数的function，不能包含任何library(devtools)，x，use_git()等其他，R包依赖的函数会在后面详细说明。\n5. 测试函数功能 先使用load_all让函数能够被测试，load_all能够模拟构建、安装和载入我们创建的R包的过程，而且load_all比实际的这个过程迭代速度更快。\nload_all() 测试函数功能\n(x \u0026lt;- \u0026quot;alfa,bravo,charlie,delta\u0026quot;) #\u0026gt; [1] \u0026quot;alfa,bravo,charlie,delta\u0026quot; strsplit1(x, split = \u0026quot;,\u0026quot;) #\u0026gt; [1] \u0026quot;alfa\u0026quot; \u0026quot;bravo\u0026quot; \u0026quot;charlie\u0026quot; \u0026quot;delta\u0026quot; 该函数能够运行，不过它并不在全局的环境中存在。\nexists(\u0026quot;strsplit1\u0026quot;, where = globalenv(), inherits = FALSE) #\u0026gt; [1] FALSE 6. commit该函数 如果使用Git，可以使用自己熟悉的方法把新的R函数commit上去。记得规范化commit的message。 Angular 提交信息规范\n7. 检查 检查所建R包的是否能够正常运行。check的时间一般比较久，但是check是一个好习惯。\ncheck() 处理check输出的结果。\n0 errors ✔ | 1 warning ✖ | 0 notes ✔ 8. 编辑对包的描述DESCRIPTION文件 修改包的作者为自己的名字或ORCID号，\n第八章会详细描述。文件内容看上去类似下面的形式：\nPackage: regexcite Title: Make Regular Expressions More Exciting Version: 0.0.0.9000 Authors@R: person(\u0026quot;Jane\u0026quot;, \u0026quot;Doe\u0026quot;, , \u0026quot;jane@example.com\u0026quot;, role = c(\u0026quot;aut\u0026quot;, \u0026quot;cre\u0026quot;)) Description: Convenience functions to make some common tasks with string manipulation and regular expressions a bit easier. License: `use_mit_license()`, `use_gpl3_license()` or friends to pick a license Encoding: UTF-8 Roxygen: list(markdown = TRUE) RoxygenNote: 7.1.2 9. 设置license 任意选择一个license，默认的似乎是MIT的。\nuse_mit_license() 10. 函数使用文档 在原文件中开发者对函数进行特殊格式的注释，并使用roxygen2包处理函数注释文档man/strsplit1.Rd的建立。关于这个包的具体使用在第十章有描述。使用RStudio可以直接打开函数R文件，每一行的开头为#'，不使用RStudio时，可以自己写comment。\n把光标放在函数内部(必须是括号内部！这样才能确定注释的是哪个函数)，使用快捷键ctrl+alt+shift+R，会在函数的开头自动生成注释文档的格式如下：\n#' Title #' #' @param x #' @param split #' #' @return #' @export #' #' @examples strsplit1 \u0026lt;- function(x, split) { strsplit(x, split = split)[[1]] } 随后使用document将注释转化为函数的Rd文档，并保存在man文件夹下：\ndocument() 此时可以使用?strsplit1来预览函数的帮助文档。在正式构建和安装包之前，不会正确连接包的文档。这消除了帮助文件之间的链接和包索引的创建等细节。\n另外，document还基于@export更新了NAMESPACE文件，这个文件是只读模式不能够进行更改的，NAMESPACE的文档内容如下：\n# Generated by roxygen2: do not edit by hand export(strsplit1) export意味着使用者可以通过载入该包来使用这个函数。\n11. 再次check() 12. 安装该包 install() 安装完之后就可以和其他包一样的使用了，可以restart R然后重新载入该包。\n参考资料  rpkg  ",
    "ref": "/blog/2022-2-22_rpkg/"
  },{
    "title": "R基础——读入和写出数据",
    "date": "",
    "description": "介绍各种形式的R的读入和写出数据的方法。 last update：2021-12-23",
    "body": "基本内容   Excel文件的读入\n  txt和csv文件的读入\n  文件的写出\n  批量读入数据并合并\n  RData和rds的储存形式\n  read.csv和read.csv2的区别\n  Excel文件的读入 在R语言实战实战这本书中表示，读取Excel文件最好的方式，是在Excel中将其导出为一个逗号分隔文件（csv），并使用读取csv的方法读取数据。或者采用xlsx包直接读取数据。xlsx包可以用来对Exceln97/2000/XP/2003/2007文件进行读取、写入和格式转换。还可以使用readxl包来读取Excel的.xls和.xlsx文件。\nread_xlsx(path, sheet = NULL, range = NULL, col_names = TRUE, col_types = NULL, na = \u0026quot;\u0026quot;, trim_ws = TRUE, skip = 0, n_max = Inf, guess_max = min(1000, n_max), progress = readxl_progress(), .name_repair = \u0026quot;unique\u0026quot;) read.xlsx( xlsxFile, sheet = 1, startRow = 1, colNames = TRUE, rowNames = FALSE, detectDates = FALSE, skipEmptyRows = TRUE, skipEmptyCols = TRUE, rows = NULL, cols = NULL, check.names = FALSE, sep.names = \u0026quot;.\u0026quot;, namedRegion = NULL, na.strings = \u0026quot;NA\u0026quot;, fillMergedCells = FALSE ) 参数：\n sheet  Excel表格含有多个表格，读取其中一个表格\n startRow  Excel表格选取部分行进行读取\n  Excel表格\n  .name.repair：是对列名进行更改，默认情况下，确保的列名是非空且特殊的即\u0026quot;unique\u0026quot;，该参数可以输入toupper——将列名变成大写字母，该参数可以输入universal——将列名中空格部分用'.\u0026lsquo;代替，也可以指定为自定义函数或其他函数，对列名进行更改。\n  示例： death.xlsx通过Excel打开如下：\n death.xlsx文件\n death.xlsx有两个子表格，且真正需要的部分是A5:F15的部分，在不想修改原始文件的情况下，读入时使用.来代替空格，可通过以下代码进行读取：\n read_excel( readxl_example(\u0026quot;deaths.xlsx\u0026quot;), range = \u0026quot;arts!A5:F15\u0026quot;, .name_repair = \u0026quot;universal\u0026quot; ) New names: * `Has kids` -\u0026gt; Has.kids * `Date of birth` -\u0026gt; Date.of.birth * `Date of death` -\u0026gt; Date.of.death  创建模板\n 参考资料：  R语言实战（第2版）  ",
    "ref": "/blog/2021-12-23_basic_r/"
  },{
    "title": "检测拷贝数变异的工具及算法【2】-ABSOLUTE",
    "date": "",
    "description": "介绍PCAWG使用6种检测拷贝数变异的工具之ABSOLUTE。 last update：2021-12-19",
    "body": "背景介绍 1. 获取绝对拷贝数数值的难点 （1）采样过程中癌细胞混合了未知比例的正常细胞——肿瘤纯度；\n（2）由于染色体数量和结构异常导致的癌细胞的实际DNA含量(倍性)是未知的；\n（3）由于正在进行的亚克隆进化，癌细胞群可能是异质性的。\n理论上，如果知道每个肿瘤细胞中DNA的含量，则可通过测得的相对拷贝数获得绝对拷贝数，或者通过单细胞测序技术解决。\n2. 芯片原始原始数据格式.CEL 对于芯片数据来说，Affymetrix SNP芯片的原始文件为CEL文件，一个CEL文件即是一个个体的全部SNP分型结果。Affymetrix基因芯片是一种生物芯片，它包含一个对一个实验有效的微阵列。为了制造这些芯片，玻璃或硅载玻片上排列有探针，根据它们是否与原始DNA样本互补，探针将表达水平(强度)报告为完全匹配(PM)和不匹配(MM)值。.CEL文件格式有多个版本，使用不同的格式。例如，版本3使用ASCII文本格式，而版本4使用二进制格式。 注意：.CEL 文件需要相应的.CDF 文件，它是存储在.CEL文件中的原始探测级数据的字典。MATLAB有一个名为affyread的内置函数，可以用来读取Windows版本软件中的.CEL 文件。\n3. SNP6.0拷贝数变异检测流程 这里介绍Affymetrix SNP6 Copy Number Inference Pipeline。\n输入：CEL文件\n输出：每个样本的片段化的拷贝数结果：genotype calls；相对的拷贝数数值且经过标准化处理，使得每个样本接近双倍体；拷贝数变异区域\n流程：\n  校准信号强度\n  计算基因型\n  将信号强度转换为拷贝数数值\n  计算拷贝数噪音\n  移除离群的探针减少噪音\n  通过减去一组预先定义的正常样本中的变化，进一步降低噪声\n  将拷贝数片段化\n  计算基因组中片段的数量，并与定义的阈值进行比较，以检查超分割情况\n  工具介绍 1. ABSOLUTE 可以评估癌细胞的纯度和倍性，计算出绝对的拷贝数和突变倍数。\n输入数据：\n可以是HAPSEG，也可以是segmentation文件，前者需要安装HAPSEG包，后者segmentation文件来自芯片CGH或大量平行测序实验的结果，可以包含其他信息，但必须包含的信息有：\u0026ldquo;Chromosome\u0026rdquo;,\u0026ldquo;Start\u0026rdquo;,\u0026ldquo;End\u0026rdquo;,\u0026ldquo;Num_Probes\u0026rdquo;,\u0026ldquo;Segment_Mean\u0026rdquo;，该模式下需要将copy_num_type参数设定为total。\n（1）HAPSEG输入：HAPSEG是一种解释癌症样本中双等位基因标记数据的概率方法。HAPSEG的工作原理是将基因组划分为不同拷贝数的片段，并在每个片段中建模四个不同的基因型。\n（2）segmentation文件：测序的结果。\n输出数据：\n步骤：\n 使用ABSOLUTE分析肿瘤DNA\n ABSOLUTE是如何进行分割片段的？\n2. ACEseq 3. Battenberg 4. CloneHD 5. JaBbA 6. Sclust 直接通过新建R Markdown文件，选择posterdown模板则自动导入模板代码，如下：\n 创建模板\n 参考资料：   CEL是什么格式的文件\n  Dentro, Stefan C., et al. \u0026ldquo;Characterizing genetic intra-tumor heterogeneity across 2,658 human cancer genomes.\u0026rdquo; Cell 184.8 (2021): 2239-2254.\n  介绍了PCAWG中拷贝数数据的来源\n",
    "ref": "/blog/2021-12-19_cnv_tools2/"
  },{
    "title": "检测拷贝数变异的工具及算法【1】-PCAWG consensus copy number",
    "date": "",
    "description": "介绍PCAWG如何使用6种工具检测拷贝数变异。 last update：2021-12-16",
    "body": "引言 PCAWG提供的拷贝数变异文件是综合6种不同的拷贝数变异提取工具的结果：\n  ABSOLUTE\n  ACEseq\n  Battenberg\n  CloneHD\n  JaBbA\n  Sclust\n  由于拷贝数结果的不同取决于segmentation的不同，而对大部分基因组的拷贝数状态的分歧来自于是否发生了整个基因组复制的分歧。因此针对6种方法中的5种首先构建了完整的断点数据，针对一致的断点数据使用6种方法得到拷贝数变异结果，解决了倍性结果的不统一后，对6种方法得到的每个segment寻求major allele和minor allele的状态的一致性，最后对每个肿瘤综合6种方法得到纯度结果，对每种方法都给予置信区间和质量星号：克隆性通过（3星），多数投票同意，协议后四舍五入亚克隆拷贝数（2星），调用最好的方法（1星）。3星代表结果非常一致，1星则是结果不那么一致的情况下选一种方法的结果输出。这样来得到最终的完整的拷贝数图谱，包含以下所有列：\nmajor_cn minor_cn position sampleID star total_cn value 工具介绍 1. ABSOLUTE 使用ABSOLUTE算法计算每个样本的纯度、倍性以及绝对DNA拷贝数，在基因组上收集基于片段的覆盖度(来自完整的阅读模板跨度)在基因组上收集，并校正GC含量和匹配偏差。【？】使用PCAWG的正常样本来进行切线归一化(tangent-normalization)处理。基于杂合性位点计算位点特异的拷贝数，使用CBS算法来得到segmentation。采用Nelder-Mead算法搜索可能的纯度和倍性解的空间，并对它们进行排序。对亚克隆拷贝数片段进行Dirichlet过程聚类，以标注相同的亚克隆拷贝数聚类状态。\n2. ACEseq 使用ACEseq计算绝对拷贝数，肿瘤纯度，并估计肿瘤细胞内容，通过结合肿瘤和基因组窗中匹配的正常基因的覆盖率以及相应SNPs的b等位基因频率(BAF)来确定绝对拷贝数。基因组使用PSBCBS包得到segmentation，在分割之前，结构变异断点通过一致的结构变异数据判断，\n利用PSCBS包将基因组分割为平等覆盖和不平衡状态的区域，在分割之前，将共识结构变异集定义的结构变异断点合并成片段边界，片段提交到共识断点估计集，通过共识断点得到的片段使用覆盖度和BAF值注释来估计样本的肿瘤细胞内容和倍性。\n注：配对的双亲特定CBS(配对的PSCBS)算法利用了CBS方法用于将总CN数据分割为来自SNP阵列的2D非阶段数据。该算法依赖于配对测试(肿瘤)和参考(正常)样本杂交到单独的阵列。\n3. Battenberg 使用Battenberg得到绝对拷贝数。针对每个SNP计算BAF和相对logR值，使用GC含量矫正logR值，匹配的正常样本用来获得种系的杂合性SNP，使用分段常数拟合(PCF)对数据进行分段，将结构变异(sv)作为先前建立的中断点，通过对纯度和倍性组合进行网格搜索，拟合克隆拷贝数图谱。\n4. CloneHD 使用CloneHD得到绝对拷贝数。cloneHD使用了隐马尔可夫模型来描述样本的拷贝数状态。cloneHD流程的第一步使用的是filterHD算法，filterHD不寻求解释数据中的亚克隆结构，是一种用于模糊分割的通用算法，是一个通用的一维离散数据概率滤波算法，类似于卡尔曼滤波。它是一个具有泊松或二项发射和跳跃扩散传播子的连续状态空间隐马尔可夫模型。它可以用于无标度平滑、模糊数据分割和数据滤波。\n5. JaBbA JaBbA整合paire-end和read depth信号来推断基因组间隔的拷贝数以及重构junction。在PCAWG共识拷贝数分析中，使用了两轮JaBbA，JbBbA的输入数据是bam文件，junction call set，以及初步分割（可选）和纯度/倍性输入，针对初步分割的结果，进一步使用CBS算法来分割得到低维度的常数拷贝数区域。\n6. Sclust 使用Sclust进行拷贝数分割，计算肿瘤纯度，肿瘤倍性以及位点特异的拷贝数（包含克隆性的和非克隆性的）。输入数据是肿瘤样本和匹配的正常样本的read counts。read counts后续用来计算肿瘤和正常样本的GC含量，接下来Sclust使用SNP数据，计算正常样本的杂合性位点的B位点频率，随后基于read ratio在数据中找到明显的跳跃来进行初次分割。\n共识拷贝数获取步骤 6种拷贝数检测的方法都使用了两步步骤：\n  第一步是把基因组分割为具有恒定拷贝状态的区域\n  第一步是确定每个片段的克隆和亚克隆拷贝数状态\n  6种方法产生的分歧结果主要是以下两个元素：\n  基因组分割的差异\n  是否发生了全基因组重复(WGD)的不确定性\n  共识拷贝数分割结果的分歧 拷贝数识别工具将一个样本的基因组分割成多个具有稳定拷贝数的区域，为了描述这些片段，需要找到片段之间的断点，断点两侧的拷贝数状态发生了变化，一旦建立起断点，不同的工具则确定每个片段内混合的拷贝数状态，包括主等位基因拷贝的数量，次等位基因拷贝的数量，以及处于这种状态的细胞的比例。\n不同的方法得到的断点有差别，有些方法调用的断点比其他方法多一个数量级。，为了解决不同方法考虑的基因组片段不同的问题，建立了共识断点集，所有的方法后续使用共识片段来判断拷贝数状态\n确定共识拷贝数片段断点的方法 创造了共识策略支持真正的断点，潜在的代价是增加假阳性，创建了完整的断点集。来自结构变异的拷贝数断点被用来量化我们的共识策略的“真阳性”和“假阴性”率。拷贝数方法把共识片段作为输入，但允许合并有相同拷贝数的相邻的片段，但是不允许产生额外的断点从而不会产生额外的片段。因为引入虚假断点的成本要小于缺失断点的成本，缺失断点的底层拷贝数状态确实发生了改变。我们为确定共识断点而开发的算法利用了这样一种见解:相邻区段之间的区域表明了一种方法的不确定性，即描述拷贝数状态变化的断点的确切位置。\n 模板\n 参考资料：   CEL是什么格式的文件\n  Dentro, Stefan C., et al. \u0026ldquo;Characterizing genetic intra-tumor heterogeneity across 2,658 human cancer genomes.\u0026rdquo; Cell 184.8 (2021): 2239-2254.\n  ",
    "ref": "/blog/2021-12-16_cnv_tools/"
  },{
    "title": "使用posterdown制作学术海报",
    "date": "",
    "description": "介绍R包posterdown的使用方法，以及最终PDF的导出。 last update：2021-12-15",
    "body": "引言 posterdown自动排版，通过调节参数满足个人制作海报的需要。\n1. 介绍 目前posterdown支持3种风格的海报模板：posterdown_html、posterdown_betterland和posterdown_betterport。以posterdown_betterport为例进行阐述。\n 目前支持的三种模板风格\n 2. 创建海报 2.1 创建模板 直接通过新建R Markdown文件，选择posterdown模板则自动导入模板代码，如下：\n 创建模板\n 2.2 添加内容 按照R Markdown语法进行代码块、图片、文字等等的添加，通过点击knit进行渲染，查看在模板基础上更改的内容。点击knit后自动生成包含html在内的如下文件：\n. ├── A\\ Better\\ Reproducible\\ Poster\\ Title.pdf ├── packages.bib ├── poster.Rmd ├── poster.html └── poster_files ├── figure-html │ ├── irisfigure-1.png │ └── myprettycode-1.png ├── header-attrs-2.11 │ └── header-attrs.js └── paged-0.15 4 directories, 7 files  图片  可以在该目录下再建立一个Figures文件夹存放Rmd中使用到的图片。\n html文件  默认生成的html文件名前缀和Rmd文件一致，可以通过在Rmd文档开头添加代码自定义生成的html文件名，这里为index.html：\nknit: (function(inputFile, encoding) { rmarkdown::render(inputFile, encoding = encoding, output_file = file.path(dirname(inputFile), \u0026#39;index.html\u0026#39;)) })  海报大小设置  通过横宽两个参数设定，支持cm，in，mm这几个长度单位，在文档开头加入代码：\nposter_height: \u0026#34;90cm\u0026#34; poster_width: \u0026#34;60cm\u0026#34;  字体大小  在文档开头加入代码：\nmain_textsize: \u0026#34;70pt\u0026#34; body_textsize: \u0026#34;30px\u0026#34; 更多参数设置可以参考GitHub上发布的官方指南，另外还有一份更详细的补充参数指南，可具体到该参数支持的长度单位也包含哪些。\n2.3 导出html以及pdf 有多种方法，可以归纳为两种，一种是将Rmd直接转换为PDF，一种是渲染的html文件转换为PDF，能够满足转换的工具都可以尝试使用，不局限于使用R或者其他的方法实现。\n  根据Github上的issue作者的提议，可以使用pagedown包中的函数:pagedown::chrome_print(\u0026quot;myfile.Rmd\u0026quot;)，直接将Rmd导出为PDF，但是该函数并未使用成功，有待后续解决。\n  使用render将Rmd导出为PDF\n  render(\u0026#34;input.Rmd\u0026#34;, \u0026#34;pdf_document\u0026#34;) 该函数导出的PDF并未进行很好的渲染。\n  尝试了使用pandoc对html转换为PDF，但是渲染效果不好。\n  使用Safari浏览器直接将knit的html文件导出为PDF，能够渲染的很好。\n    参考资料：  具体的参数调整官方文档  ",
    "ref": "/blog/2021-12-15_posterdown/"
  },{
    "title": "计算机组成",
    "date": "",
    "description": "计算机组成 last update：2021-12-06",
    "body": "引言 1. 计算机组成 计算机的组成部件可以分为三大类：中央处理单元（CPU）、主存储器和输入/输出子系统。\n中央处理单元 用于数据的运算。在大多数体系结构中，它有3个组成部分：算术逻辑单元（ALU）、控制单元、寄存器组、快速存储定位。\n  算术逻辑单元\n对数据进行逻辑、移位和算术运算。\n  寄存器\n用来存放临时数据的高速独立的存储单元。\n  控制单元\n控制各个子系统的操作。控制是通过从控制单元到其他子系统的信号来进行。\n  主存储器 是存储单元的集合，每一个存储单元都有唯一的标识，称为地址。\n",
    "ref": "/blog/2021-12-06_consist_of_computer/"
  },{
    "title": "潜在语义分析（LSA）",
    "date": "",
    "description": "潜在语义分析 last update：2021-11-26",
    "body": "引言 潜在语义分析（Latent sematic analysis, LSA）是一种无监督的学习方法。特点是通过矩阵分解来完成，使用的是非概率的话题分析模型，可以通过奇异值分解的方法进行矩阵因子分解，特点是分解的矩阵正交，非负矩阵分解是另一种矩阵的因子分解方法，特点是分解的矩阵非负。\n1. 单词向量空间和话题向量空间 1.1 单词向量空间 给定一个含有$n$个文本的集合$D=\\left { d_1,d_2,\u0026hellip;,d_n \\right }$，在所有文本中出现的$m$个单词的集合$W=\\left { w_1,w_2,\u0026hellip;,w_m \\right }$，将单词在文本中出现的数据用一个单词-文本矩阵表示，记作$X$: $$ \\begin{bmatrix} x_{11} \u0026amp;x_{12} \u0026amp;\u0026hellip; \u0026amp;x_{1n} \\ x_{21} \u0026amp;x_{22} \u0026amp;\u0026hellip; \u0026amp;x_{2n} \\ \\vdots \u0026amp;\\vdots \u0026amp; \u0026amp;\\vdots \\ x_{m1} \u0026amp;x_{m2} \u0026amp;\u0026hellip; \u0026amp;x_{mn} \\end{bmatrix} $$\n元素$x_{ij}$表示单词$w_i$在文本$d_j$中出现的频数或权值，由于单词的种类很多，每个文本出现单词的种类通常较少，所以单词-文本矩阵是一个稀疏矩阵。\n权值通常用单词频率-逆文本频率（TF-IDF）表示，定义是： $$ TFIDF_{ij}=\\frac{tf_{ij}}{tf_{·j}}log\\frac{df}{df_i} \\space i=1,2,\u0026hellip;,m; \\space j=1,2,\u0026hellip;,n $$ $\\frac{tf_{ij}}{tf_{·j}}$表示单词$w_i$出现在文本$d_j$中的频数比上文本$d_j$中出现的所有单词的频数之和，一个单词在一个文本中出现的频数越高，这个单词在文本中的重要度就越高；$\\frac{df}{df_i}$表示全部文本数比上含有单词$w_i$的文本数，一个单词在整个文本集合中出现的文本数越少，这个单词就越能代表其所在文本的特点，重要度就越高。TF-IDF是两种重要度的积，表示综合重要度。\n单词向量空间模型直接使用单词-文本矩阵的信息，第$j$列向量$x_j$表示文本$d_j$： $$ x_j=\\begin{bmatrix} x_{1j}\\ x_{2j}\\ \\vdots\\ x_{mj} \\end{bmatrix} $$ 其中$x_{ij}$是单词$w_i$在文本$d_j$的权值，两个单词向量的内积货标准化内积（余弦）表示对应的文本之间的语义相似度，因此文本$d_i$ 与$d_j$ 之间的相似度为: $$ x_i·x_j，\\frac{x_{i}·x_{j}}{\\left | x_{i}\\right |\\left | x_{j}\\right |} $$ $\\cdot $表示向量的内积，$\\left | \\cdot\\right |$表示向量的范数，向量的1-范数即向量元素绝对值之和。两个文本中共同出现的单词越多，其语义就越接近，这个是文本信息处理的一个基本原理。\n单词向量空间的优点是模型简单，计算效率高，局限性是内积相似度未必能够准确表达两个文本的语义相似度，因为自然语言的单词具有一词多义性以及多词一义性，因此基于单词向量的相似度计算存在不精确的问题。\n1.2 话题向量空间 1.2.1 什么是话题向量空间 两个文本的语义相似度可以体现在两者的话题相似度上，话题就是文本所讨论的内容或主题，文本一般含有若干个话题，如果两个文本的话题相似，那么两者的语义应该也相似。话题可以由若干个语义相关的单词表示，则能够解决基于单词的模型存在的问题。话题的个数通常远远小于单词的个数。\n给定一个含有$n$个文本的集合$D=\\left { d_1,d_2,\u0026hellip;,d_n \\right }$，在所有文本中出现的$m$个单词的集合$W=\\left { w_1,w_2,\u0026hellip;,w_m \\right }$，将单词在文本中出现的数据用一个单词-文本矩阵表示，记作$X$，同上单词向量空间中的表示。假设所有的文本共含有$k$个话题，假设每个话题由一个定义在单词集合$W$上的$m$维向量表示，称为话题向量： $$ t_l=\\begin{bmatrix} t_{1l}\\ t_{2l}\\ \\vdots\\ t_{ml} \\end{bmatrix},l=1,2,\u0026hellip;,k $$ 其中$t_{il}$是单词$w_i$在话题$t_l$的权值，权值越大，单词在话题中的重要度就越高，$k$个话题向量张成一个话题向量空间，话题向量空间$T$是单词向量空间$X$的一个字空间。\n单词-话题矩阵： $$ T=\\begin{bmatrix} t_{11} \u0026amp;t_{12} \u0026amp;\u0026hellip; \u0026amp;t_{1k} \\ t_{21} \u0026amp;t_{22} \u0026amp;\u0026hellip; \u0026amp;t_{2k} \\ \\vdots \u0026amp;\\vdots \u0026amp; \u0026amp;\\vdots \\ t_{m1} \u0026amp;t_{m2} \u0026amp;\u0026hellip; \u0026amp;t_{mk} \\end{bmatrix} $$\n1.2.2 文本在话题向量空间的表示 将单词向量投影到话题向量空间$T$中，得到话题向量空间的一个向量$y_j$ $$ y_j=\\begin{bmatrix} y_{1j}\\ y_{2j}\\ \\vdots\\ y_{mj} \\end{bmatrix},j=1,2,\u0026hellip;,n $$ 其中$y_{lj}$是文本$d_j$在话题$t_l$的权值，$l=1,2,\u0026hellip;,k$，权值越大，该话题在该文本中的重要度就越高。\n话题-文本矩阵： $$ Y=\\begin{bmatrix} y_{11} \u0026amp;y_{12} \u0026amp;\u0026hellip; \u0026amp;y_{1n} \\ y_{21} \u0026amp;y_{22} \u0026amp;\u0026hellip; \u0026amp;y_{2n} \\ \\vdots \u0026amp;\\vdots \u0026amp; \u0026amp;\\vdots \\ y_{k1} \u0026amp;y_{k2} \u0026amp;\u0026hellip; \u0026amp;y_{kn} \\end{bmatrix} $$\n1.2.3 从单词向量空间到话题向量空间的线性变换 单词-文本矩阵$X$可以近似的表示为单词-话题矩阵与话题-文本矩阵的乘积形式，这就是潜在语义分析： $$ X\\approx TY $$ 直观上潜在语义分析是将文本在单词向量空间的表示通过线性变换转换为在话题向量空间中的表示：\n原始的单词向量空间中，两个文本的相似度可以由对应的向量的内积表示$x_i·x_j$，经过潜在语义分析，在话题向量空间中，两个文本的相似度可以由对应的向量的内积表示：$y_i·y_j$。\n2. 潜在语义分析 2.1 矩阵奇异值分解算法 奇异值分解（SVD）是一种矩阵因子分解方法，任何一个$m\\times n$矩阵，都可以表示为三个矩阵的乘积形式，分别是$m$阶正交矩阵、由降序排列的非负的对角线元素组成的$m\\times n$矩阵对角矩阵和$n$阶正交矩阵，成为该矩阵的奇异值分解，矩阵的奇异值分解一定存在但不唯一，可以看做是矩阵数据压缩的一种方法。奇异值分解不要求矩阵是方阵。\n 正交矩阵：正交矩阵（Orthogonal Matrix）是指其转置等于其逆的矩阵。\n 奇异值分解是在平方损失（弗罗贝尼乌斯范数）意义下对矩阵的最优近似，紧奇异值分解对应着无损压缩，截断奇异值分解对应着有损压缩。潜在语义分析根据确定的话题个数$k$对单词-文本矩阵$X$进行截断奇异值分解： $$ X\\approx U_k（\\Sigma_k V{k}^{T}） $$ 矩阵的奇异值分解可以看作是将其对应的线性变换分解为旋转变换、缩放变换及旋转变换的组合，得到话题空间$U_k$，以及文本在话题空间的表示$\\Sigma_k V{k}^{T}$。\n2.2 非负矩阵分解 $$ X\\approx WH $$\n2.2.1 损失函数或代价函数 损失函数可以有以下几种：\n  平方损失\n  散度\n  2.2.2 算法 以上两个目标函数：平方损失和散度知识对变量$W$和$H$之一的凸函数，而不是同时对两个变量的凸函数，因此找到全局最优比较困难。Lee提出的基于“乘法更新规则”的优化算法，交替地对$W$和$H$进行更新。\n文献  《统计学习方法》第2版 李航  ",
    "ref": "/blog/2021-11-26_statistic-lsa/"
  },{
    "title": "隐马尔可夫模型（HMM）",
    "date": "",
    "description": "隐马尔可夫模型的介绍以及在获取拷贝数变异中的应用 last update：2021-11-19",
    "body": "引言 1. 马尔可夫模型的基本概念 来对2段氨基酸序列x和y进行残基比对，认为存在3种比对关系的状态：\n M：残基能够比对上但不一定相等 X：序列x的残基比对到1个空位，或x上发生了1次插入 Y：序列y的残基比对到1个空位，或y上发生了1次插入  序列比对就是在上述3个状态中不断转换的过程：\n $M(i,j)$ : $x_i$比对到$y_j$时，序列x从1到$i$和序列$y$从1到$j$最好的比对分数 $X(i,j)$ : $x_i$比对到空位时，序列x从1到$i$最好的比对分数 $Y(i,j)$ : $y_j$比对到空位时，序列y从1到$j$最好的比对分数  转移（从一个状态到另外一个状态）概率：\n$$ a_{kl} = P (X_t=S_l|X_{t-1}=S_k) $$\n$$ a_{lk} = P (X_t=S_k|X_{t-1}=S_l) $$\n转移矩阵：\n \n 设定：\n $\\delta$ ：Gap open（d）的概率 $\\epsilon$ ：Gap extension（e）的概率   马尔可夫链\n 先根据转移概率得到一个转移概率矩阵：\n 转移矩阵\n 假设匹配状态是XMMY：\n 匹配状态\n 计算匹配状态的概率： $$ P(XMMY)=\\alpha_{XM}\\alpha_{MM}\\alpha_{MY} = (1-\\epsilon)(1-2\\delta)\\delta $$\n通过上面的例子，下面介绍马尔可夫模型的一些概念：\n  马尔可夫过程：\n马尔可夫过程是一类随机过程，该过程的“将来”仅依赖“现在”，而不依赖“过去”，把一个总随机过程看作是状态的不断转移，表达式为： $$ x(t+1)=f(x(t)) $$\n  马尔可夫链：\n时间和状态都离散的马尔可夫过程。\n  马尔可夫状态链的状态空间： $$ S = \\begin{Bmatrix} S_1,\u0026amp; S_2,\u0026amp; S_3,\u0026hellip; \\end{Bmatrix}S_i\\in R $$\n  马尔可夫链在时刻$t$处于状态$S_i$条件下，在时刻$t+1$转移到状态$S_j$的转移概率是条件概率： $$ P_{ij}(t, t+1)=P\\begin{Bmatrix} x_{t+1}=S_j|x_t=S_i \\end{Bmatrix} $$\n  由于马氏链在时刻 $t$ 从任何一个状态$S_i$出发，到下一时刻 $t+1$，必然转移到$S_j$，$j=1,2,…$，诸状\n态中的某一个，所以有：\n $$ \\forall _{i^{\\forall}}\\sum_{j}P_{ij}(t,t+1)=1 $$  当$P_{ij}(t,t+1)$与$t$无关时，为齐次马尔可夫链，通常说到的马尔可夫链都是指齐次的。马尔可夫链除了仅依赖于上一次观测值的一阶马尔可夫链，还可以依赖多个连续观测数据，后者称之为高阶马尔可夫链。\n  2. 马尔可夫模型的组成   随机序列变量 $$ X = \\begin{Bmatrix} x_1,\u0026amp; x_2,\u0026amp; x_3,\u0026hellip;,x_t \\end{Bmatrix} $$\n  状态空间 $$ S = \\begin{Bmatrix} S_1,\u0026amp; S_2,\u0026amp; S_3,\u0026hellip; \\end{Bmatrix}\\space\\space S_i\\in R \\space\\space\\space i=1,2,\u0026hellip;,n $$\n  转移概率矩阵 $$ P=\\begin{Bmatrix} P_{ij}=P(x_{t+1}=S_j|x_t=S_i) \\end{Bmatrix} $$\n  初始状态向量 $$ \\prod =\\begin{Bmatrix} \\pi=P(x_0=S_i) \\end{Bmatrix} , \\space\\space\\space i=1,2,\u0026hellip;,n $$\n  3. 隐马尔可夫模型 隐马尔可夫模型是结构最简单的动态贝叶斯网，可以用五元组来描述分别为：\n 状态空间$S$ 状态对应的观测空间$X$ 状态转移矩阵$A$ 每个状态下观测事件的概率矩阵$B$ 初始状态概率分布$\\pi$  给出这五个参数就能够确定一个隐马尔可夫模型，通常用参数$\\lambda=\\begin{Bmatrix}A,B,\\pi\\end{Bmatrix}$来指代。\n举一个新的例子：基因预测——给定序列预测编码区\n隐马尔可夫模型在状态的基础上，增加符号的概念，每个状态可以以不同的概率产生可观测到的符号。在例子中，给定的基因组序列为观测到的符号串，编码和非编码为2种隐状态，即编码与否是未知的，需要通过已知的符号来推测。\n 示例：马尔可夫链\n 转移矩阵：\n基因组会同时包含编码和非编码区域，自我转移的箭头表示状态的连续。\n 转移矩阵\n 转移概率矩阵：\n 转移概率矩阵\n $$ a_{kl} = P (X_t=S_l|X_{t-1}=S_k) $$\n生成概率：\n 生成概率\n 这里的状态路径无法进行观测，需要根据符号路径来推测状态，引入生成概率，状态$S_k$时产生符号$b$的概率： $$ e_{k}(b) = P (y_i=b|X_{i}=S_k) $$ 生成概率矩阵（在这里有两个）：\n 2个生成概率矩阵\n 训练集：正确标记好了编码和非编码区域的DNA序列。\n根据训练集填好上述转移概率矩阵和生成概率矩阵，来对未知的给定基因组序列反推最可能的基因组状态路径。\nLogarithmic transformation：引入对数计算将乘法变成加法，对转移/生成矩阵概率取$log_{10}$（在计算机运算中，很容易因为连乘的次数的增加，很容音因为数值过小，出现下溢的问题）\n测试序列：CGAAAAAATCG\n根据训练集得到转移概率矩阵和生成概率矩阵：\n取log10的转移概率矩阵\n取log10的生成概率矩阵\n 动态规划进行序列比对：\n 序列比对\n 假设n状态和c状态默认的分布比例分别是$log_{10}(0.8)$和$log_{10}(0.2)$，使用序列比对的方法，找到概率最大的值为起点进行回溯。最终找到的状态链为：NNCCCCCCNNN。\n根据示例我们可以得到一个大概的步骤来对隐马尔可夫模型进行应用：\n 首先要确定具体问题中什么是状态，什么是符号 其次根据状态列出转移概率矩阵，根据状态和符号列出生成概率矩阵 根据训练集填上矩阵的具体数值 根据具体问题使用相应的解决方法(本例子中根据数据来对未知的给定基因组序列反推出最可能的基因组状态路径，迭代使用动态规划进行序列比对)  实际应用中关注隐马尔可夫模型的3个基本问题以及对应的解决方法：\n  估算问题：\n给定模型$\\lambda=\\begin{Bmatrix}A,B,\\pi\\end{Bmatrix}$，如何有效计算观测序列$x=\\begin{Bmatrix} x_1,x_2,\u0026hellip;,x_n\\end{Bmatrix}$出现的概率？也就是模型和观测序列之间的匹配程度。\n解决：foreward和backward算法\n  解码问题：\n给定模型$\\lambda=\\begin{Bmatrix}A,B,\\pi\\end{Bmatrix}$和观测序列$x=\\begin{Bmatrix} x_1,x_2,\u0026hellip;,x_n\\end{Bmatrix}$，如何找到和观测序列最匹配的状态序列？也就是找到隐藏的模型状态。\n解决：Viterbi算法\n  学习问题或训练问题：\n给定观测序列$x=\\begin{Bmatrix} x_1,x_2,\u0026hellip;,x_n\\end{Bmatrix}$，如何调整模型参数$\\lambda=\\begin{Bmatrix}A,B,\\pi\\end{Bmatrix}$，使得该观测序列发生的概率最大？也就是根据训练样本学得最优的参数模型。\n解决：Baum-Welch算法\n  4. 隐马尔可夫模型判断CNV 以PennCNV为例介绍HMM在实际判断CNV中的应用。PennCNV是一个免费的检测SNP分型阵列芯片的拷贝数变异的工具，目前可以处理Illumina和Affymetrix array的数据来得到信号强度，若使用其他类型的SNP芯片数据和寡核苷酸芯片需要预先处理文件的格式。PennCNV使用隐马尔可夫模型整合多个来源的信息来对单个样本推断CNV。它与基于分割的算法不同，除了单独考虑信号强度外，还考虑了SNP等位基因比例分布等因素。\n PennCNV通过基因型来检测拷贝数变异的算法流程（Wang K et al. 2007）\n 在PennCNV中使用的是一阶HMM，隐状态是人为设定的离散值1，2，3，4，5，6，各自对应的总拷贝数数值和CNV基因型如上表所示。注意这里最大的拷贝数状态设定为拷贝数为4，因为4个和4个以上的拷贝无法进行区分。符号是信号强度值的两种形式：BAF和LRR。结合BAF和LRR可以判断不同的拷贝数以及区分出拷贝中性的LOH（文章中没有具体说怎么结合BAF和LRR数据的，但是通过公示我的理解是BAF和LRR同时发生的联合概率作为HMM的生成概率）。\n 隐状态，拷贝数数值及其对应的描述（Wang K et al. 2007）\n 下面介绍一些定义：\n  原始的信号强度数据需要经过“5步标准化”（http://icom.illumina.com/iom/software.ilmn），每个SNP的X值和Y值分别代表实验得到经过标准化的等位基因A和B的信号强度值，$R$为总信号强度： $$ R = X + Y $$\n   $\\theta$为相对的等位信号强度比率： $$ \\theta = \\frac{arctan(Y/X)}{\\pi/2} $$ 该计算分母为$\\pi/2$可以将数值$\\theta$压缩在-1～1之间。\n  B Allele Frequency （BAF）通常指的是标准化的等位基因B和A的相对信号强度：\n BAF公式（Wang K et al. 2007）\n 0代表只检测到了A这个allele对应的荧光信号，分型结果为AA；1代表只检测到了B这个allele对应的荧光信号，分型结果为BB；0.5代表A和B这两个allele的荧光信号强度相等，分型结果为AB。$\\theta_{AA}$,$\\theta_{AB}$,$\\theta_{BB}$都是根据正常样本得到的值，荧光信号存在一定程度的扰动，因此BAF的取值是在0-1范围波动的值。\n  $R_{observed}$是观测值，$R_{expected}$是通过算法拟合得到的数值代表了正常样本中的信号强度，每个SNP的$log$ R 比率（LRR）：\n  $$ LRR={log_{2}}(R_{observed}/R_{expected}) $$\n​\tLRR = 0\t拷贝数为2；LRR \u0026gt; 0 拷贝数增加；LRR \u0026lt; 0 拷贝数减少\n介绍完定义之后，来确定转移概率和生成概率以及对应矩阵。\n  LRR的生成概率：\n是混合的均匀和正态分布模型， $$ P(r|z)=\\pi_r+(1-\\pi_r)\\phi(r;\\mu_{r,z},S_{r,z}) $$ $(\\phi·；·)$是均值为$\\mu_{r,z}$，标准差为$S_{r,z}$的正态分布，均匀分布用于对于芯片中随机的信号波动和可能的基因组错误注释和错误assmbly的建模。\n  BAF的生成概率：\n对于每一个隐状态（除了状态1），有不同可能的基因型也就有不同模式的BAF。\n BAF生成概率（Wang K et al. 2007）\n   对于染色体X进行特殊处理：\n将染色体X中所有的SNP的LRR值减去1个常数，使得针对女性，平均的LRR值不是0，针对男性，LRR不是单拷贝删除的LRR的参考值，因为正常的男性染色体X的状态就是state2不应该是state3。\n  隐状态的转移概率：\n即两个相邻SNP发生拷贝数状态改变的概率，一般来讲，临近的SNPs拷贝数状态不太可能发生变化，但是较远的SNPs的拷贝数状态更容易发生改变。因此需要找到转移概率和距离的关系，那么转移概率为：\n $$ p(z_i=l|z_{i-1}=j)=\\left\\{\\begin{matrix} 1-\\sum_{k=2}^{b}p_{j,k-1}(1-e^{d_i/D}),if \\space l=j \\\\ p_{j,l-1}(1-e^{d_i/D}),if \\space l\\neq j \\end{matrix}\\right. $$ $D$是一个常数，当状态为4时设为100Mb，其他状态为100kb，p是未知参数，用Baum-Welch算法进行估计，得到最优的参数后，再使用Viterbi算法进行隐状态的判断。在PennCNV的分析中，排除了所有包含小于等于\u00032个SNP的CNV，因为这些CNV中可能存在较高的假阳性比例。\n  介绍算法之前先定义几个概念：\n $O = O_1,O_2,\u0026hellip;,O_t$\t输出的观察序列符号 $P(O|\\lambda)$ 给定模型参数时，输出符号序列$O$的概率 $a_{ij}$\t从状态$S_i$到状态$S_j$的转移概率 $b_j(O_t)$\t在状态$S_j$时，输出$O_t$的概率 $a_t(j)$\t输出部分符号序号$O = O_1,O_2,\u0026hellip;,O_t$达到状态$S_j$时的前向概率  前向算法：\n 前向算法\n  前向算法步骤\n Vertibi算法\n介绍完定义，明确完我们的五元组，我们再明确一下我们的问题是解码问题，解码问题对应的解法是Viterbi算法，介绍一下该算法具体过程：\n Vertibi算法步骤\n 参考   Wang, Kai, et al. \u0026ldquo;PennCNV: an integrated hidden Markov model designed for high-resolution copy number variation detection in whole-genome SNP genotyping data.\u0026rdquo; Genome research 17.11 (2007): 1665-1674.\n  图：Kai Wang et al. Genome Res. 2007;17:1665-1674\n  Circular Binary Segmentation from Jeremy Teibelbaum\u0026rsquo;s blog\n  CKVkit：https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1004873\n  Ming-Lian\u0026rsquo;s blog\n  隐马尔可夫模型：https://www.cnblogs.com/skyme/p/4651331.html\n  coursera生物信息学：导论与方法第四周\n  动态贝叶斯网络\n  ",
    "ref": "/blog/2021-11-19_hmm/"
  },{
    "title": "R：批量读入文件并合并",
    "date": "",
    "description": "字符串处理 last update：2021-11-17",
    "body": "引言 使用do.call批量读入文件并合并。\n1. 基本处理步骤 source_dir \u0026lt;- \u0026#34;文件所在路径\u0026#34; file \u0026lt;- list.files( path = source_dir, pattern = \u0026#34;*.txt\u0026#34;, # 目标文件夹下需要的文件的格式 all.files = F, full.names = F, recursive = F, include.dirs = F ) allfile \u0026lt;- lapply(file, function(x){read.csv2(paste0(source_dir, x), sep = \u0026#34;\\t\u0026#34;)}) combine \u0026lt;- do.call(rbind, allfile) 2. 涉及到的需求和参数设定   文件名作为新列补充进数据框\n  对文件名进行更改\n  参考    ",
    "ref": "/blog/2021-11-17_docall/"
  },{
    "title": "synapser",
    "date": "",
    "description": "字符串处理 last update：2021-07-24",
    "body": "引言 一个提供批量下载Synapser数据的R包。\n1. 登陆 synLogin(\u0026#34;baomihai@sina.com\u0026#34;,\u0026#34;******\u0026#34;) Welcome, baomihai@sina.com!NULL 参考  biostars-How to install gdc-client in Ubnutu  ",
    "ref": "/blog/2021-8-31_synapser/"
  },{
    "title": "处理字符串的两个R包:stringi和stringr",
    "date": "",
    "description": "字符串处理 last update：2021-07-24",
    "body": "引言 stringr包是建立在stringi上的，stringi包使用ICU C库提供准确、快速的常见字符串操作，stringr提供了最重要和最常用的字符串处理函数。\nstringr stringr包中所有的函数都以str_开头，第一个参数为字符串向量。对应的在base函数中也有功能一致的函数，记得对比两者之间的异同。\n1. 找到自己需要的数据 tcga_mut \u0026lt;- read.csv2(\u0026#34;/home/tzy/projects/CNX-method/data/TCGA/mc3.v0.2.8.PUBLIC.nonsilentGene.xena\u0026#34;,sep = \u0026#34;\\t\u0026#34;) saveRDS(tcga_mut, file = \u0026#34;/home/tzy/projects/CNX-method/data/TCGA/tcga_mut.rds\u0026#34;) save(tcga_mut, file = \u0026#34;/home/tzy/projects/CNX-method/data/TCGA/tcga_mut.RData\u0026#34;) 参考  biostars-How to install gdc-client in Ubnutu  ",
    "ref": "/blog/2021-7-24_stringr_stringi/"
  },{
    "title": "gdc-client",
    "date": "",
    "description": "gdc-client加入环境变量 last update：2021-07-20",
    "body": "引言 之前一直用别的方法下载数据，这次使用了gdc-client命令行去下载GDC上TCGA driver gene mutation的一批数据。\n步骤 1. 找到自己需要的数据 这是我本次要下载的数据\n点击数据下载地址发现出现如下界面，其中id就是使用gdc-client下载的文件对应的id\n对于Open access data，使用这两种方法下载\n下载了MAC的Client版本\n2. 安装 解压下载的文件，如果双击会发现出现erro：\n且常规的对~/.bash_profile文件添加环境变量也不可以，正确做法是：\n./gdc-client #(to verify that program works) cp -pi ./gdc-client /usr/local/bin #(if this does not work) sudo cp -pi ./gdc-client /usr/local/bin 在任何路径都可以打开。\n3. 使用  下载单个文件  gdc-client download id  下载多个文件  将含有多个文件的id和名字等信息的页面存储为txt，download加上-m，进行批量下载。\ngdc-client download -m ./PanCan-Driver_Open_GDC-Manifest.txt 参考  biostars-How to install gdc-client in Ubnutu  ",
    "ref": "/blog/2021-7-20_gdc_client/"
  },{
    "title": "R储存数据",
    "date": "",
    "description": "R储存数据 last update：2021-07-20",
    "body": "引言 rds比RData省空间，为什么？\n步骤 1. 找到自己需要的数据 tcga_mut \u0026lt;- read.csv2(\u0026#34;/home/tzy/projects/CNX-method/data/TCGA/mc3.v0.2.8.PUBLIC.nonsilentGene.xena\u0026#34;,sep = \u0026#34;\\t\u0026#34;) saveRDS(tcga_mut, file = \u0026#34;/home/tzy/projects/CNX-method/data/TCGA/tcga_mut.rds\u0026#34;) save(tcga_mut, file = \u0026#34;/home/tzy/projects/CNX-method/data/TCGA/tcga_mut.RData\u0026#34;) 参考  biostars-How to install gdc-client in Ubnutu  ",
    "ref": "/blog/2021-7-20_rdata/"
  },{
    "title": "orthogonal sequencing techology",
    "date": "",
    "description": "什么是正交测序技术 last update：2021-07-15",
    "body": "引言 看文献的时候看到这个词\u0026quot;orthogonal sequencing techology\u0026quot;，好奇这是什么技术，去了解了一下。以及为什么通过这个技术得到的重测序数据能够用来验证signature的存在？\n步骤 1. 更改 config.html 文件 2. 更改 main.scss 文件 参考  图片来源  ",
    "ref": "/blog/2021-7-15_orthogonal_sequencing_tech/"
  },{
    "title": "hugo主题增加valine评论功能_test",
    "date": "",
    "description": "增加评论功能，可以匿名 last update：2021-06-08",
    "body": "步骤 1. 配置Leancloud 这部分详细参考：hugo博客添加评论系统Valine\n2. 更改 comments.html 文件 将整体内容替换成如下代码：\n\u0026lt;!-- valine change from origin code--\u0026gt; {{- if .Site.Params.valine.enable -}} \u0026lt;!-- id 将作为查询条件 --\u0026gt; \u0026lt;div id=\u0026#34;vcomments\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;//cdn1.lncld.net/static/js/3.0.4/av-min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#39;//unpkg.com/valine/dist/Valine.min.js\u0026#39;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; new Valine({ el: \u0026#39;#vcomments\u0026#39; , appId: \u0026#39;{{ .Site.Params.valine.appId }}\u0026#39;, appKey: \u0026#39;{{ .Site.Params.valine.appKey }}\u0026#39;, notify: \u0026#39;{{ .Site.Params.valine.notify }}\u0026#39;, verify: \u0026#39;{{ .Site.Params.valine.verify }}\u0026#39;, avatar:\u0026#39;{{ .Site.Params.valine.avatar }}\u0026#39;, placeholder: \u0026#39;{{ .Site.Params.valine.placeholder }}\u0026#39;, visitor: \u0026#39;{{ .Site.Params.valine.visitor }}\u0026#39; }); \u0026lt;/script\u0026gt; {{- end -}} 3. 引入评论 layouts/_default/single.html 中引入评论，本主题已有配置：\n{{ if not ( eq .Params.comments false) }} {{ .Render \u0026#34;comments\u0026#34; }} {{ end }} 参考   Hugo评论插件集成之Valine\n  hugo博客添加评论系统Valine\n  关于该主题已有的配置：给Hugo个人博客添加Valine评论系统\n  Valine配置项\n  ",
    "ref": "/blog/2021-6-8_comment/"
  },{
    "title": "hugo增加TOC",
    "date": "",
    "description": "增加文章内标题导航 last update：2021-06-08",
    "body": "引言 根据hugo-future-imperfect-slim主题中issue提到的TOC更改版本，改进后进行配置应用。\n步骤 1. 更改 config.html 文件 在[params] 内容下加入以下参数：\ntoc = true # 默认显示toc tocWords = 400 #超过400字显示toc 2. 更改 main.scss 文件 添加TableOfContents：\n#TableOfContents { border: $secondary-border; ul { list-style-type: none; padding-inline-start: 1.5em; } } /* ========================================================================== Add-Ons ========================================================================== */ /* reCaptcha */ 3. 更改 single.html 文件 在content内容中添加{{ .TableOfContents }}\n\u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt; {{ .Render \u0026#34;featured\u0026#34; }} {{ .TableOfContents }} #此处添加一行 {{ .Content }} \u0026lt;/div\u0026gt; 参考   图片来源\n  hugo官方文档\n  github issue\n  可以尝试的其他方法：HuGo中文章加入目录\n  Hugo博客侧边导航栏\n  Hugo添加文章目录toc\n  ",
    "ref": "/blog/2021-6-8_toc/"
  },{
    "title": "博客优化计划",
    "date": "",
    "description": "仍然有很多需要做的，更上一层楼 last update：2021-06-08",
    "body": "引言 分为功能改进、美观改进。\n1. 博客功能改进   个人博客归档（已完成）\n  date的时间更换成自动化填充，每次手动填写很麻烦\n  搜索中文优化，目前速度较慢\n  更改归档页面时间0001\n  每篇博文的分享页面超链接到对应网址\n      删除不需要的语言支持，只保留英文和中文\n  增加评论功能Valine（已完成）\n  参考：https://www.smslit.top/2018/07/08/hugo-valine/\n    分类更加细化，最好能有层层分类\n  ABOUT页面填充自己的个人信息\n  翻页添加页码\n  博文添加目录（已完成）\n  2. 博客整体美观   每个博文的图片选取大小合适的\n  标题的英文或中文的字距过大，比如下图的 引言 和 博客功能改进\n    ",
    "ref": "/blog/2021-6-8_optimization_of_the_blog/"
  },{
    "title": "hugo博客配置归档页面",
    "date": "",
    "description": "hugo没有自带的归档设置，需要手动添加 last update：2021-06-07",
    "body": "引言 hugo没有自带的归档设置，需要手动添加。\n操作步骤   在taozy_blog/layouts/_default/目录下创建 archives.html 文件\n  将taozy_blog/layouts/_default/目录下的 single.html 内容复制进 archives.html 文件（single.html的格式就是每篇博文的格式，也可以采用主题的contact.html的格式或者about.html的格式）\n  找到archives.html 文件中的{{ .Content }} 替换为下面的内容:\n  {{ range (.Site.RegularPages.GroupByDate \u0026#34;2006\u0026#34;) }} \u0026lt;h3\u0026gt;{{ .Key }}\u0026lt;/h3\u0026gt; \u0026lt;ul class=\u0026#34;archive-list\u0026#34;\u0026gt; {{ range (where .Pages \u0026#34;Type\u0026#34; \u0026#34;blog\u0026#34;) }} \u0026lt;li\u0026gt; {{ .PublishDate.Format \u0026#34;2006-01-02\u0026#34; }} -\u0026gt; \u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; {{ end }} \u0026lt;/ul\u0026gt; {{ end }} 对上述代码进行解读:\n 归档目录  Pages \u0026ldquo;Type\u0026rdquo; \u0026ldquo;blog\u0026quot;即归档目录设置为content/blog/下的内容，如果去掉blog，引号内留空，就会自动归档根目录下的文件，也就是content目录的文件。\n 可选归档时间  .Site.RegularPages.GroupByDate \u0026ldquo;2006\u0026rdquo;：按年归档 .Site.RegularPages.GroupByDate \u0026ldquo;2006-01\u0026rdquo;：按年月归档\n在config.toml文件[menu]中仿照其他添加以下代码，使得主页上栏显示该分类：  [[menu.main]] name = \u0026#34;Archives\u0026#34; identifier = \u0026#34;archives\u0026#34; url = \u0026#34;/archives/\u0026#34; pre = \u0026#34;\u0026lt;i class=\u0026#39;fa fa-newspaper\u0026#39;\u0026gt;\u0026lt;/i\u0026gt;\u0026#34; weight = 6 如下：\n完成归档页面的建立。\n参考：   配置主要参考：为hugo添加归档页面\n  我为什么要从 Hexo 更换到 Hugo\n  解读部分主要参考：Hugo添加归档页面\n  ",
    "ref": "/blog/2021-6-7_%E9%85%8D%E7%BD%AE%E5%BD%92%E6%A1%A3/"
  },{
    "title": "ERROR: Could not find a version that satisfies the requirement torch==1.5.1 ",
    "date": "",
    "description": "ERROR: No matching distribution found for torch==1.5.1 last update：2021-06-04",
    "body": "引言 为了在集群上跑1000个模拟样本的SigprofilerExtractor工具，在集群上自己新建的环境里安装，解决安装bug，并成功使用。\n解决bug思路   发现依赖torch1.5.1版本\n  通过pip install安装失败\n  使用whl安装发现没有对应python3.9的版本\n  根据版本推测1.5.1不能在python3.9安装\n  重建新环境，安装python3.8，进而安装1.5.1\n  成功\n  具体实施 使用sigprofilerextractor发现报错如下：\nERROR: Could not find a version that satisfies the requirement torch==1.5.1 (from sigprofilerextractor) (from versions: 0.1.2, 0.1.2.post1, 0.1.2.post2, 1.7.1, 1.8.0, 1.8.1) ERROR: No matching distribution found for torch==1.5.1 需要安装torch1.5.1版本，直接conda安装和pip安装都失败了 另外提示中表明可以通过source使用whl安装，网址如下：\nCannot install torch just with pip, try again with source from https://download.pytorch.org/whl/torch_stable.html Looking in links: https://download.pytorch.org/whl/torch_stable.html 选择匹配版本，发现报错，其中网址中36指的是python3.6版本\nERROR: Could not install requirement torch==1.5.1+cpu from https://download.pytorch.org/whl/cpu/torch-1.5.1%2Bcpu-cp39-cp39-linux_x86_64.whl because of HTTP error 403 Client Error: Forbidden for url: https://download.pytorch.org/whl/cpu/torch-1.5.1%2Bcpu-cp39-cp39-linux_x86_64.whl for URL https://download.pytorch.org/whl/cpu/torch-1.5.1%2Bcpu-cp39-cp39-linux_x86_64.whl torch1.5.1没有支持3.9的版本，但是我的python是3.9的\n(R4) [taozy@hpc-login-gpu01 ~]$ python Python 3.9.1 | packaged by conda-forge | (default, Dec 21 2020, 22:08:58) [GCC 9.3.0] on linux Type \u0026#34;help\u0026#34;, \u0026#34;copyright\u0026#34;, \u0026#34;credits\u0026#34; or \u0026#34;license\u0026#34; for more information. 创建一个新环境去跑sigprofilerextractor：sigminer环境，这个python是3.8的 先在这个环境里安装sigminer，使用conda安的时候老是出现以下报错\nSolving environment: failed with initial frozen solve. Retrying with flexible solve. Solving environment: failed with repodata from current_repodata.json, will retry with next repodata source. 有可能是镜像的问题，换源 还没换源莫名其妙好了\nCollecting package metadata (repodata.json): done Solving environment: done proceed yes之后继续下载 载入sigminer时有问题\n\u0026gt; library(sigminer) Error: package or namespace load failed for ‘sigminer’ in dyn.load(file, DLLpath = DLLpath, ...): unable to load shared object \u0026#39;/slst/home/taozy/miniconda3/envs/sigminer/lib/R/library/data.table/libs/datatable.so\u0026#39;: /slst/home/taozy/miniconda3/envs/sigminer/lib/R/library/data.table/libs/datatable.so: symbol GOMP_loop_nonmonotonic_dynamic_next, version GOMP_4.5 not defined in file libgomp.so.1 with link time reference In addition: Warning message: package ‘sigminer’ was built under R version 4.0.5 \u0026gt; install.packages(\u0026#34;data.table\u0026#34;) 是库的问题，重新安装data.table，解决 在python3.8下安装发现问题解决，torch1.5.1成功安装 运行时发现自动调用python3.9，通过py_path强制设定3.8版本\nsigprofiler_extract(simulate.tally_X, output = \u0026#34;PCAWG_1000\u0026#34;, range = 2:30, nrun = 100, init_method = \u0026#34;random\u0026#34;, is_exome = FALSE, use_conda = FALSE, py_path = \u0026#34;~/miniconda3/envs/sigminer/bin/python\u0026#34; ) 运行报错python3.8没有sigprofilerExtractor\npython: /slst/home/taozy/miniconda3/envs/sigminer/bin/python libpython: /public/slst/home/taozy/miniconda3/envs/sigminer/lib/libpython3.8.so pythonhome: /slst/home/taozy/miniconda3/envs/sigminer:/slst/home/taozy/miniconda3/envs/sigminer version: 3.8.2 | packaged by conda-forge | (default, Mar 5 2020, 17:11:00) [GCC 7.3.0] numpy: /slst/home/taozy/miniconda3/envs/sigminer/lib/python3.8/site-packages/numpy numpy_version: 1.20.3 NOTE: Python version was forced by use_python function Python module SigProfilerExtractor not found, try installing it... WARNING: Retrying (Retry(total=4, connect=None, read=None, redirect=None, status=None)) after connection broken by \u0026#39;NewConnectionError(\u0026#39;\u0026lt;pip._vendor.urllib3.connection.VerifiedHTTPSConnection object at 0x2b8645858070\u0026gt;: Failed to establish a new connection: [Errno -2] Name or service not known\u0026#39;)\u0026#39;: /simple/sigprofilerextractor/ WARNING: Retrying (Retry(total=3, connect=None, read=None, redirect=None, status=None)) after connection broken by \u0026#39;NewConnectionError(\u0026#39;\u0026lt;pip._vendor.urllib3.connection.VerifiedHTTPSConnection object at 0x2b8645858c40\u0026gt;: Failed to establish a new connection: [Errno -2] Name or service not known\u0026#39;)\u0026#39;: /simple/sigprofilerextractor/ WARNING: Retrying (Retry(total=2, connect=None, read=None, redirect=None, status=None)) after connection broken by \u0026#39;NewConnectionError(\u0026#39;\u0026lt;pip._vendor.urllib3.connection.VerifiedHTTPSConnection object at 0x2b86458584f0\u0026gt;: Failed to establish a new connection: [Errno -2] Name or service not known\u0026#39;)\u0026#39;: /simple/sigprofilerextractor/ WARNING: Retrying (Retry(total=1, connect=None, read=None, redirect=None, status=None)) after connection broken by \u0026#39;NewConnectionError(\u0026#39;\u0026lt;pip._vendor.urllib3.connection.VerifiedHTTPSConnection object at 0x2b8645858ac0\u0026gt;: Failed to establish a new connection: [Errno -2] Name or service not known\u0026#39;)\u0026#39;: /simple/sigprofilerextractor/ WARNING: Retrying (Retry(total=0, connect=None, read=None, redirect=None, status=None)) after connection broken by \u0026#39;NewConnectionError(\u0026#39;\u0026lt;pip._vendor.urllib3.connection.VerifiedHTTPSConnection object at 0x2b864586a550\u0026gt;: Failed to establish a new connection: [Errno -2] Name or service not known\u0026#39;)\u0026#39;: /simple/sigprofilerextractor/ ERROR: Could not find a version that satisfies the requirement SigProfilerExtractor==1.1.0 (from versions: none) ERROR: No matching distribution found for SigProfilerExtractor==1.1.0 Error: Error installing package(s): \u0026#39;SigProfilerExtractor==1.1.0\u0026#39; Execution halted 指定该版本的工具进行安装\npip install SigProfilerExtractor==1.1.0 安装成功\nInstalling collected packages: joblib, threadpoolctl, scipy, scikit-learn, pillow, pyparsing, six, cycler, kiwisolver, python-dateutil, matplotlib, nimfa, pytz, pandas, seaborn, sigProfilerPlotting, patsy, statsmodels, SigProfilerMatrixGenerator, reportlab, psutil, PyPDF2, xlrd, SigProfilerExtractor Successfully installed PyPDF2-1.26.0 SigProfilerExtractor-1.1.0 SigProfilerMatrixGenerator-1.1.30 cycler-0.10.0 joblib-1.0.1 kiwisolver-1.3.1 matplotlib-3.4.2 nimfa-1.4.0 pandas-1.2.4 patsy-0.5.1 pillow-8.2.0 psutil-5.8.0 pyparsing-2.4.7 python-dateutil-2.8.1 pytz-2021.1 reportlab-3.5.67 scikit-learn-0.24.2 scipy-1.6.3 seaborn-0.11.1 sigProfilerPlotting-1.1.15 six-1.16.0 statsmodels-0.12.2 threadpoolctl-2.1.0 xlrd-1.2.0 终于跑上了\n/opt/gridview//pbs/dispatcher/mom_priv/jobs/2439514.node1.SC: line 16: out_dir: command not found sigminer version 2.0.1 - Star me at https://github.com/ShixiangWang/sigminer - Run hello() to see usage and citation. Warning message: package ‘sigminer’ was built under R version 4.0.5 Loading required namespace: reticulate Python environment configuration. ==================== python: /slst/home/taozy/miniconda3/envs/sigminer/bin/python libpython: /public/slst/home/taozy/miniconda3/envs/sigminer/lib/libpython3.8.so pythonhome: /slst/home/taozy/miniconda3/envs/sigminer:/slst/home/taozy/miniconda3/envs/sigminer version: 3.8.2 | packaged by conda-forge | (default, Mar 5 2020, 17:11:00) [GCC 7.3.0] numpy: /slst/home/taozy/miniconda3/envs/sigminer/lib/python3.8/site-packages/numpy numpy_version: 1.20.3 NOTE: Python version was forced by use_python function ************** Reported Current Memory Use: 0.41 GB ***************** Extracting signature 2 for mutation type 176 The matrix normalizig cutoff is 17600 参考：  how can i install torch  ",
    "ref": "/blog/2021-6-4_torch1.5.1_error/"
  },{
    "title": "Excel数字长度超13位尾号变0",
    "date": "",
    "description": "Excel number format last update：2021-05-27",
    "body": "引言 小雨毕业填各种表格，发现数字很长的时候会直接用0替代超长位数的数字，检索之后，给她解决了这个小问题。\n操作方法 设置数字格式，在自定义中输入@\n 重新输入可以发现已经可以了\n  参考资料：  Excel数字长度超13位尾号变0或E+，教你这招只用一个0就能搞定  ",
    "ref": "/blog/2021-5-27_excel_number/"
  },{
    "title": "线程和进程",
    "date": "",
    "description": "Threads and Processes  last update：2021-05-26",
    "body": "引言 看了一下廖雪峰的官方网站中对多线程和多进程的讲解，写的真是又简洁又明了，结合今天workshop中zk提到的并行计算，简单汇总写个学习笔记。\n操作系统可以同时执行多任务，比如同时运行浏览器、QQ和word，CPU执行代码是按照顺序一条条的执行。\n操作系统执行多任务是让CPU对多个任务轮流进行交替执行，比如让浏览器执行0.1秒，让word执行0.1秒。\n不管是单核还是多核的CPU，都可以同时运行多个任务，单核CPU执行任务交替进行，多核CPU在任务数量多于CPU的核数时，也是交替执行任务。\n一、进程 计算机中一个任务为一个进程，浏览器是一个进程，word也是一个进程。部分进程内部需要同时执行多个子任务，比如使用word一边打字一边检查拼写，一边后台打印，子任务就是线程。\n操作系统调度的最小任务单位是线程。由于一个应用程序可以有，多个进程，也可以有多个线程，实现任务的方法包括：\n多进程模式（每个进程只有一个线程）：\n  多线程模式（一个进程有多个线程）：\n  多进程＋多线程模式（复杂度最高）：\n  二、线程 线程包含在进程内，多任务既可以多进程来实现，也可以单进程内的多线程实现，也可以混合多进程和多线程。\n和多线程相比，多进程的缺点在于：\n 创建进程比创建线程开销大，尤其是在Windows系统上； 进程间通信比线程间通信要慢，因为线程间通信就是读写同一个变量，速度很快。  多进程的优点在于：\n多进程稳定性比多线程高，因为在多进程的情况下，一个进程崩溃不会影响其他进程，而在多线程的情况下，任何一个线程崩溃会直接导致整个进程崩溃。\n多线程编程的特点在于：\n 经常需要读写共享数据，并且需要同步，比如播放电影时一个线程播视频，一个线程播音频，两个线程需要协调运行保持音画同步，因此多线程编程的复杂度高，调试更困难。  三、串行，并发与并行   串行 多个任务，执行时一个执行完再执行另一个。\n  并发 多个线程在单个核心运行，同一时间一个线程运行，系统不停切换线程，看起来像同时运行，实际上是线程不停切换。\n  并行 每个线程分配给独立的核心，线程同时运行。\n  四、CPU与核心  物理核  物理核数量=cpu数(机子上装的cpu的数量)*每个cpu的核心数\n 虚拟核  所谓的4核8线程，4核指的是物理核心。通过超线程技术，用一个物理核模拟两个虚拟核，每个核两个线程，总数为8线程。在操作系统看来是8个核，但是实际上是4个物理核。 通过超线程技术可以实现单个物理核实现线程级别的并行计算，但是比不上性能两个物理核。\n 单核cpu和多核cpu  都是一个cpu，不同的是每个cpu上的核心数，多核cpu是多个单核cpu的替代方案，多核cpu减小了体积，同时也减少了功耗，一个核心只能同时执行一个线程。\n参考资料：   廖雪峰的官方网站-多线程\n  认识cpu、核与线程\n  ",
    "ref": "/blog/2021-5-24_threads_and_processes/"
  },{
    "title": "逻辑回归",
    "date": "",
    "description": "logistic regression  last update：2021-04-12",
    "body": "引言  线性回归  假设数据包含 尺寸 和 重量 两组，根据这两组数据用 最小二乘法 拟合一条线后，我们可以做如下的事情：\n  计算r平方来确定两个变量是否相关\n  计算p值确定R平方是否具有统计显著性\n  用于预测，如果一个新鼠标有某重量，可以根据这个线来预测其大小\n  多元回归  假设用 体重 和 血容量 来预测大小，拟合曲线可做上述三个同样的事情，还可以用离散型数值来预测大小。\n比较模型  进行正态回归，使用权重来预测大小。\n逻辑回归 S型函数定义：\n  S 型函数会产生以下曲线图：\n y' 是逻辑回归模型针对特定样本的输出。 z 是 b + w1x1 + w2x2 + … wNxN w 的值是该模型学习的权重，b 是偏差。 x 的值是特定样本的特征值。  线性回归的损失函数是平方损失。逻辑回归的损失函数是对数损失函数。\n  逻辑回归预测事物是对还是错，而不是连续的事物，通常用于分类，根据该目的拟合了“S”形曲线，可以给出概率。\n假设这里用体重来预测肥胖，或者基因型和体重来预测肥胖，即不仅可以处理体重和年龄等连续数值，还可以处理离散数值，可以测试每个变量是否对预测肥胖有用。\n 最大似然法拟合曲线  本质就是不停的计算，选择具有最大似然的曲线。\n最大似然 最大似然的目标是找到使分布适合数据的最佳方法。不同类型的数据存在不同类型的分布，让分布适合数据可以让数据的使用更轻松，更通用，使它适用于相同类型的每个实验，假设称重了一批老鼠如下：\n在这种情况下，认为老鼠体重可能呈正态分布，正态分布意味着：\n  老鼠的重量 接近均值 或平均值。\n  期望测量值围绕平均值相对对称。（虽然看起来不是完全对称，但是也没有非常明显的偏向）\n  正态分布存在多种大小和形状，如下：\n当确定形状之后，要找出居中的位置。\n假设选任何一个旧的正态分布，下图分布表示测量的大多数值应该接近平均值，看看它对数据的拟合程度（黑色虚线处是分布平均值）：\n发现测量的大多数值和分布的均值相差很大（右边多数的测量值的似然很低），如果将正态分布移到其均值和平均体重相同的位置：\n发现红色圈出部分的似然相对高，继续移动正态分布，这些测量值的似然再次下降：\n可以在分布中心的位置，绘制观察到数据的似然，从左侧开始，计算观察数据的似然，将分布向右移动并重新计算似然：\n当尝试了所有可能的位置，就可以将正态分布置于需要的位置，即最大化观察我们所测量值的似然的位置，以上都是平均值的最大似然估计，这里讨论的是分布的均值，不是数据的均值吗，接下来找出标准差的最大似然估计：\n日常对话中，概率和似然（likelihood）可能指的是同一个概念，但是在统计学中，似然（likelihood）指的是：尝试针对给定的一组观察到的测量值，找到分布的最佳均值或标准差，这就是找到适合数据分布的过程。\n参考：   《StatQuest》\n  《统计会犯错：如何避免数据分析中的统计陷阱》\n  逻辑回归(Logistic Regression)：计算概率|机器学习速成课程\n  ",
    "ref": "/blog/2021-4-11_%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"
  },{
    "title": "p值",
    "date": "",
    "description": "什么是p值，记录一下。last update：2021-04-10",
    "body": "介绍  p值的含义    假设存在药物A和药物B，想知道两种药物的区别？\n维基百科定义：p值是假设检验中假设零假设为真时观测到至少与实际观测样本相同极端的样本的概率（似乎很拗口）。\np值是介于0-1之间的数字，量化我们相信两种药物不同的信心，p值越接近0，越相信两者不同。当p的阈值为0.05意味着，假设两种药物之间没有差异，执行多次且相同的实验，那么只有5%的实验会得出错误决定，简单来说，p值是对意外的测量。\np值能够帮助确定两种药物是否不同，但是不能告诉我们有什么不同，不管差异是都大还是小，都可以使用较小的p值，即较小的p值不代表差异是大还是小，只是代表意外的结果概率更小 。\n 阈值0.05的由来  不出于逻辑或统计原因，只是科学惯例。\n 术语：假阳性  指的是没有差异时却获得小的p值的情况。\n 术语：假设检验（Hypothesis testing）  试图确定这些药物是否相同的想法。\n 术语：零假设（Null Hypothesis）  零假设是药物相同，p值帮助我们决定是否拒绝零假设。\n统计显著性检验分支 分为以下两个主要的：\n  R.A.Fisher\n  Neyman and Pearson\n  控制假设检验的两类错误很重要：\n 第一类错误  无效说成有效（取伪）。\n第二类错误。  有效判成无效（弃真）。\n这两种错误不能同时消除，但是可以给出一种规范的决策过程来确保第一类错误的可能性只在预先确定的比率下发生（奈曼和皮尔逊），这个比率为显著性水平α（false positive rate），可以根据经验和期望基础设置合适的α，举例：\n建立10%的第一类错误率，设置α = 0.1，当希望决策更加保守，可以将α设置成0.01或更小。确定α后，可以考察哪个 检验过程 的第二类错误的比率更低。\n该体系下，定义一个原假设，即“无效”的假设，再定义一个备择假设，“效应大于0”，构建一个检验去比较这两个假设，假设使用p值，如果p\u0026lt;α，拒绝原假设（费希尔的检验过程把注意力放在揭示任何一个特定的试验证据的强度），p值的大小只用来是否“拒绝原假设”。\n误区 误区1：一次试验的第一类错误率为3.2%\n注意，仅仅通过一次试验不能得到第一类错误率，这是由检验过程决定的，不是一次试验的结果得到的，一个检验过程得到的是一个长期的第一类错误率，不能对应到每一次试验得到的真实p值和对应的第一类错误率。\n误区2：p值越小，差异越大\np值仅仅反应我们相信我们存在差异的信心，p值越小，越有信心拒绝零假设，不管差异是大还是小。\n误区3：P值就是假阳性率\n拒绝原假设犯错属于一类错误，错误的概率就是我们的α，p值只是我们根据一次抽样结果计算出来的值。P \u0026lt; α）表达的是在一次抽样中出现当前结果及更极端结果的可能性比我们认为的在一次抽样中不可能发生的小概率事件的概率更小。\n置信区间 一个置信区间包含一个点估计，和该估计的不确定性。举例：\n如果想检验这个效应量是否显著区别于0，可以构建一个95%的置信区间来检验这个区间是否包含0。\n参考：   《StatQuest》\n  《统计会犯错：如何避免数据分析中的统计陷阱》\n  统计知识|谈谈P值和α水平\n  ",
    "ref": "/blog/2021-4-07_p%E5%80%BC/"
  },{
    "title": "使用CIBERSORTx网页版分析免疫浸润",
    "date": "",
    "description": "申请cibersort.R总是没搞清楚，决定还是先使用网页版进行免疫浸润分析，记录一下。last update：2021-04-06",
    "body": "前言 最近需要对TCGA和PCAWG的表达数据进行免疫浸润水平分析，使用了R包immunedeconv,其中TCGA已经有文献的supplement给出了不同免疫浸润工具进行分析的结果，PCAWG需要自己手动分析，其中CIBERSORT在immunedeconv包中运行需要两个文件：LM22.txt，CIBERSORT.R，需要在官网：https://cibersortx.stanford.edu/ 进行申请。\n上传数据  mixture file  官网上会列出上传数据的要求，我上传了PCAWG的基因表达counts矩阵，数据的第一列是genesymbol的名称，而且第一列的列名需要加上：“GeneSymbol”，数据的第一行是样本的名称。\n注意上传数据的时候，需要勾选自己上传的数据属于哪种类型，否则在分析数据中无法选择到自己上传的数据。\n进行分析 选择cell fraction的custom，得到免疫浸润细胞比例结果，选择custom分析自己的数据。\n勾选LM22作为参考matrix，选择自己上传的matrix作为mixture matrix，需要比较样本间时记住勾选abs。\n运行过程中，可以看到报错信息和输出信息。\n",
    "ref": "/blog/2021-4-06-cibersort/"
  },{
    "title": "使用Latex写论文",
    "date": "",
    "description": "使用Latex写论文可以减少排版的时间，它对文献的引用以及排序非常友好。last update：2021-03-06",
    "body": "前言 最近写文章的时候，发现修改时调整参考文献的引用，是一件非常麻烦的事情，于是找到了一种简便的方法进行调整，发现了用Latex写论文原来这么好用（据涛哥和翔哥说，word也可以自动调整引用文献顺序，而我一直不知道\u0026hellip;）。\n主要内容  LaTex基本语法 模板的使用 文献的引用 排版的调整 特殊符号的引用 图片表格的插入  使用的工具  Oneleaf —— Online LaTeX Editor（推荐）  优点：不用本地搭建环境；在线编辑并渲染；部分投稿期刊直接提供链接模板。\n MacTeX—— For mac  mac的我还没有安过，仅列出来供参考。\n TexWorks —— For windows（我觉得很好用）。  除了上面列出来的，还有很多其他的，根据自己的喜好使用吧。\n基本语法  整体框架  注意到一个部分有开始也有结束，中间就是这个部分的内容。\n\\documentclass{article} \\begin{document} First document. This is a simple example, with no extra parameters or packages included. \\end{document}  preamble  在LaTex中，所有在document内容之前的都称为preamble,在preamble中可以定义整个文档的格式、使用的语言、你需要使用到的宏包、以及其他的元素。举例：\n\\documentclass[12pt, letterpaper]{article} %设置 \\usepackage[utf8]{inputenc} %加载了名叫inputenc的宏包，设置使用utf-8来编码。 在[]方括号中都是一些参数的选择，documentclass中设置了字体大小为12pt（默认的字体大小是10pt），纸张大小为信纸，其他的设置可以看Oneleaf的文档说明。\n这些内容也属于preamble：\n标题\n\\title{First document} 作者\n\\author{cat} 日期\n\\date{March 2021} 谢言\n\\thanks{funded by the Overleaf team}  document内容  字体的简单格式可以通过以下代码实现：\nSome of the \\textbf{greatest} %字体加粗 discoveries in \\underline{science} %加入下划线 were made by \\textbf{\\textit{accident}}. %斜体   还有更多的字体变换可以更改，具体参考字体格式，来个简单的应用示例感受一下它的实用性。\nOneleaf 示例 1. 模板的使用 进入 Oneleaf模板，选择合适的模板 这其中包括国科大的毕业论文模板、开题报告模板，以及各种杂志期刊、简历、信件、海报、报告、作业和写书的模板等等（部分期刊杂志会提供Oneleaf的模板）。\n 以论文写作为例 随便打开一个模板，最右边是实时的渲染结果，中间是可以编辑的部分，左边是模板的目录下文件。\n  左边的目录下存储了4个文件：\n 以.bib结尾的文件  通常用来存储引用文献的信息，其中引用文献需要用特定的格式——BibTex存储，可以通过谷歌学术、百度学术或者其它方式进行导出（谷歌学术的导出功能经常会崩溃），如何使用Bibtex格式进行文献引用请跳转 点击跳转。\n 以.bst结尾的文件  这个文件通常由期刊或杂志提供，设置了参考文献出现的文章结尾的方式，比如：设置排序方式，设置作者名称是缩写还是全称，标题的大小写等等，一般不需要自行维护，而且可以根据自己的需求来在.tex中重新调整。\n 以.tex结尾的文件  这个是进行文档内容编辑的文件，可以在这个文件中加载宏包，进行内容以及格式的更改。\n 以.cls结尾的文件  这个文件通常是类文件，通过文档最前面的\\documentclass导入，这里的\\documentclass[options]{class}是用来指定文档类型的，可以通过options参数来定制文档类的属性，不同的选项之间需要用逗号隔开，比如这里的\\documentclass[final,3p]{CSP}，其中final指的不在页面的边缘标记一个黑色框，这个3p对它的解释是：\n formats the article to the look and feel of the final format of model 3+ journals.\n 我没明白这个3+model是什么意思，但是通过调试，发现这个数字越大，页面距就越大。\n另外别的模板中还存在这些文件：\n .bbl文件  这是编译之后形成的文件，这里直接就显示了编译后的形式，可以直接下载PDF文件。\n .sty文件  这是包文件，通常使用\\usepackage导入。\n2. 内容的编辑以及参考文献的引用 内容的编辑 载入宏包的方法是在文档开始前\\begin{document}，写入\\usepackage{package}\n这里介绍几个常用的宏包：\n  数学公式 - amsmath\n  插图 - graphicx\n  颜色 - xcolor\n  表格 - array\n  中文 - ctex, xecjk\n  西文 otf 字体 - fontspec\n  英文下划线 - geometry\n  特别的，当要使用英文下划线-时，比如写入sigminer包中的函数名read_maf时，并不能直接识别下划线，需要载入该包来处理，或者给每处下划线改成\\_也可以不用载入包来识别。\n 超链接 - hyperref  语法：\\usepackage[options]{hyperref}\n示例：加入超链接，同时将文献也超链接到reference中，并且设置超链接的颜色，常用的设为蓝色或者黑色。\n\\usepackage[backref, colorlinks,linkcolor=blue]{hyperref}   \n文献的引用  保存引用文献信息(google)  如下图所示，谷歌学术中可以直接得到BibTex这种引用格式，将文献信息存储在.txt中，然后更改后缀为.bib即可。\n  点击 BibTex 后会弹出下图所示页面，复制内容至.bib文件内即可。\n   在tex文件中对引用格式进行设置  在文档结束位置\\end{document}前，增加对参考文献格式以及引用的设置，比如：\n\\bibliographystyle{bibft}\\it \\bibliography{bibfile} bibft是模板自带并自己命名的格式文件，这是由.cls文件定义的，bibfile就是制作好的bibtex文件，\n注意这里的文献引用格式有很多种，除了模板中定义的格式，可以通过参数的调整将格式更改为自己想要的，比如常用的，在方括号中标注数字，并且根据文献引用的先后顺序对reference排序：\n\\begin{document} \\bibliographystyle{unsrt} \\bibliographystyle{unsrt} %根据引用顺序自动排序 \\bibliography{bibfile.bib} %引用文献的文件 \\end{document} 我认为最方便的地方就是这里，能够根据文献引用的顺序对reference进行自动排序。\n 保存引用文献信息(zotero)  在zotero中设置导出为BibTex，在zotero中通过command+shift+c就可以直接复制出该文献的BibTex引用格式。\n   在tex文件中进行引用  通常在正文中有很常见的几种文献引用格式： 温哥华格式（上标形式） 哈佛格式（直接显示作者和发表年份） IEEE 格式（方括号内标注引用顺序）\n在文中一般使用\\cite{}进行引用，括号中的内容就是BibTex中的第一个参数，这个是可以自定义的，通常都是作者的姓或者名+发表年份+论文题目的首个单词。\n@inproceedings{song2013hierarchical, title={Hierarchical representation using NMF}, author={Song, Hyun Ah and Lee, Soo-Young}, booktitle={International conference on neural information processing}, pages={466--473}, year={2013}, organization={Springer} } 另外还有宏包natbib，通过不同形式的cite比如：\n\\citet：\n\\citet{jon90} ## Jones et al. (1990) \\citep：\n\\citep{jon90}\t## (Jones et al., 1990) \\citeyear：\n\\citeyearpar{jon90} ## (1990) \u0026hellip;\u0026hellip;\n该宏包的使用方式如下。\n\\usepackage[option]{natbib} \\bibliographystyle{natbib} \\bibliography{bibfile} 3. 表格的制作 分为以下两个部分：\n 手动输入表格（适合小型表格） 其他工具进行表格转换   Excel中的表格  可以在Excel中使用插件：Excel2Latex，该插件能够将Excel表格转化为LaTex的表格形式。\nWord中的表格  可以使用pandoc直接转换为.tex格式，不过转换之后不是完美的，可能需要手动调整一下。\n示例：\npandoc test.docx -o test.tex 其他文件形式的表格  比如在R当中得到的表格，可以使用stargazer包把结果输出为LaTex格式，或者xtable包。\n以xtable包为例：\n\u0026gt; install.packages(\u0026#34;xtable\u0026#34;) #安装xtable \u0026gt; library(xtable) #载入 \u0026gt; data(iris) # 示例数据 \u0026gt; xtable(head(iris),digits=3,caption=\u0026#34;Head of Iris Data\u0026#34;) #将iris数据前6行 # 保留三位小数 #标题设为\u0026#34;Head of Iris Data\u0026#34;，导出为LaTex格式 % latex table generated in R 4.0.2 by xtable 1.8-4 package % Sat Mar 6 20:04:47 2021 \\begin{table}[ht] \\centering \\begin{tabular}{rrrrrl} \\hline \u0026amp; Sepal.Length \u0026amp; Sepal.Width \u0026amp; Petal.Length \u0026amp; Petal.Width \u0026amp; Species \\\\ \\hline 1 \u0026amp; 5.100 \u0026amp; 3.500 \u0026amp; 1.400 \u0026amp; 0.200 \u0026amp; setosa \\\\ 2 \u0026amp; 4.900 \u0026amp; 3.000 \u0026amp; 1.400 \u0026amp; 0.200 \u0026amp; setosa \\\\ 3 \u0026amp; 4.700 \u0026amp; 3.200 \u0026amp; 1.300 \u0026amp; 0.200 \u0026amp; setosa \\\\ 4 \u0026amp; 4.600 \u0026amp; 3.100 \u0026amp; 1.500 \u0026amp; 0.200 \u0026amp; setosa \\\\ 5 \u0026amp; 5.000 \u0026amp; 3.600 \u0026amp; 1.400 \u0026amp; 0.200 \u0026amp; setosa \\\\ 6 \u0026amp; 5.400 \u0026amp; 3.900 \u0026amp; 1.700 \u0026amp; 0.400 \u0026amp; setosa \\\\ \\hline \\end{tabular} \\caption{Head of Iris Data} \\end{table} 表格的介绍 表格的基本格式和要素如下（2行2列表格）：\n\\documentclass{article} \\usepackage{float}%提供float浮动环境 \\usepackage{makecell} %%用来基线 \\begin{table}[h] \\centering %%表居中 \\caption{table} %%表格标题 \\begin{tabular}{|c|c|} %%{cc} 表示各列元素对齐方式，left-l,right-r,center-c，两个c表示两列，｜表示增加垂直方向基线 \\hline %%\\hline 在此行下面画一横线 a \u0026amp; b \\\\\\hline c \u0026amp; d\\\\ \\hline \\end{tabular} \\end{table} \\end{document}   当表格太大或者太小的时候，有非常多的解决办法，可以通过调整字体的长或宽，也可以直接整体调整表格的大小，本质都是通过在tabular类外，套上调整表格的参数设置。\n通过调整字体的宽度（mm是百分比，60mm就是60%）：\n\\resizebox{\\textwidth}{60mm}{} 通过调整表格的大小：\n\\usepackage{graphicx} \\begin{table} \\caption{表格标题} \\scalebox{0.9}{ %缩小至原来的90% \\begin{tabular} …… \\end{tabular}} \\end{table} 文献中常用的三线表可以通过以下Latex实现：\n\\documentclass{article} \\usepackage{float}%提供float浮动环境 \\usepackage{booktabs} %%提供命令\\toprule、\\midrule、\\bottomrule \\usepackage{makecell} %%用来基线 \\usepackage{geometry} \\usepackage{amsmath} %\\geometry{papersize={40cm,80cm}} \\geometry{left=1cm,right=1cm,top=3cm,bottom=1cm} \\begin{document} %经典三线表 \\begin{table}[H] %%H为当前位置 \\caption{\\textbf{test title}}%标题 \\centering%把表居中 \\begin{tabular}{ccc}%四个c代表该表一共四列，内容全部居中 \\toprule[1.5pt]%第一道横线 year \u0026amp; month \u0026amp; day \\\\ \\midrule%第二道横线 2021 \u0026amp; 3 \u0026amp; 5 \\\\ \\bottomrule[1.5pt]%第三道横线 \\end{tabular} \\end{table} \\end{document}   4. 图片的引入 LaTeX插入图片时，支持格式有各种：png, pdf, jpg, eps等等。\n 准备图片  将图片全部保存在目录下的同一个文件夹下，方便查找，注意图片的命名尽量避免中文，特殊字符等等(这里就只用了一个文件，我就直接放在目录下了)。\n 图片基本语法  必须加载graphicx等包来支持图片的导入。\n\\documentclass{article} \\usepackage{graphicx} \\graphicspath{ {images/} } \\begin{document} The universe is immense and it seems to be homogeneous, in a large scale, everywhere we look at. \\includegraphics{universe} There's a picture of a galaxy above \\end{document}  给图片进行排版（排版有很多种，现在展示的是两个图片并排）    \\usepackage{graphicx} %%插入图片的宏包 \\usepackage{float} %%设置图片浮动位置的宏包 \\usepackage{subfigure} %%插入多图时用子图显示的宏包 \\begin{figure} %%旋转子系统姿态角 \\centering \\subfigure{ \\label{fig:subfig:a} %% label for first subfigure \\includegraphics[width=4cm,height=4cm]{taoziyu.jpg}} \\hspace{1in} \\subfigure{ \\label{fig:subfig:b} % label for second subfigure \\includegraphics[width=4cm,height=4cm]{taoziyu.jpg}} \\caption{The same cute cat (a) cute cat1. (b) cute cat2.} %% caption用于图表的标题 \\label{fig:attitude} %% label for entire figure \\end{figure} 参考资料  Oneleaf官方文档 BibTex的使用方法 latex documentclass 及相关布局 document class LaTex - 从出门到掉到坑 LaTex插入图形，表格 LaTeX排版札记 用R语言快速生成Latex表格 LaTeX高效写作系列：word表格转LaTeX  题外之言 该markdown文档中新使用了以下几个有趣的功能：\n 自定义锚实现页内跳转  在跳转目的地附近加上\u0026lt;span id=\u0026quot;jump\u0026quot;\u0026gt;目的地\u0026lt;/span\u0026gt;，在需要点击跳转的地方加上[点击跳转](#jump)\n 更改超链接颜色，更改字体颜色 多图片并列 ",
    "ref": "/blog/2021-3-05-latex_blog/"
  },{
    "title": "About",
    "date": "",
    "description": "Hugo, the world’s fastest framework for building websites",
    "body": "test page\n",
    "ref": "/about/"
  },{
    "title": "Hugo+Github+阿里云域名搭建个人博客（附Netlify部署方法）",
    "date": "",
    "description": "这是我第一次搭建个人博客，记录一下搭建过程。last update：2021-01-21",
    "body": "前言 最近师兄和涛哥都分享了这个流程：如何使用了R包blogdown搭建个人博客，但是我和轩哥在使用的过程中发现一个小问题，有一些主题似乎并不能很好的被blogdown安装的hugo来应用，几番求解无果，暂时将这个问题搁置，因为太喜欢这个theme不想放弃，所以找了一种不用blogdown的方法去搭建，终于取得成果。\n搭建流程  下载Hugo  Mac直接使用brew安装即可\n其他的系统可以直接参考官方文档：hugo官方文档\nbrew install hugo 部分主题依赖extended version（比如我使用的这个主题），所以检查一下Hugo版本\nhugo version Hugo Static Site Generator v0.80.0/extended darwin/amd64 BuildDate: unknown  使用Hugo建博客  #新的博客的名字就叫blog hugo new site blog ls archetypes\tcontent\tlayouts\tresources\tthemes config.toml\tdata\tstatic  设置博客主题  从Hugo的官网找到自己喜欢的主题：Hugo themes\n我使用了这个主题：hugo-future-imperfect-slim\n下面开始设置博客主题\ncd blog/themes #blog就是刚才新创建的博客目录，themes是它的子目录 git clone https://github.com/pacollins/hugo-future-imperfect-slim.git #点击主题页的download，进入GitHub主页，找到code⬇当中的网址进行clone #注意主题要下在theme目录下 cp themes/hugo-future-imperfect-slim/exampleSite/config.toml . #使用模板自带的配置文件替换blog目录下的配置文件 有的模板没有exampleSite目录，或者是config.toml文件名为其他的名字，不管怎样，用模板目录下的config文件替换blog目录下的config文件即可。\n像轩哥用的主题 hyde，根据其在github上的安装提示，对blog目录下的config文件首行增加theme = \u0026quot;hyde\u0026quot; 即可，无需拷贝模板的config文件。\n以及主题 npq-hugo，它的模板config文件不在exampleSite目录下，而是themes/npq-hugo/example-config.toml。\n 回到blog目录下创建新博文  cd .. hugo new posts/test.md #会在content/post文件夹下创建test.md的文件，可以直接对其进行修改 开始可能不会修改，可以根据主题目录中的范例进行模仿，我选择主题的范例文件储存在：\nblog/themes/hugo-future-imperfect-slim/exampleSite/content/blog\n 进行预览  hugo server -D Start building sites … | EN | FR | PL | PT | DE | ES | ZH-CN | ZH-TW | JA | NL -------------------+----+----+----+----+----+----+-------+-------+----+----- Pages | 11 | 8 | 8 | 8 | 8 | 8 | 8 | 8 | 8 | 8 Paginator pages | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 Non-page files | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 Static files | 27 | 27 | 27 | 27 | 27 | 27 | 27 | 27 | 27 | 27 Processed images | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 Aliases | 3 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 Sitemaps | 2 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 Cleaned | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 Built in 108 ms Watching for changes in /Volumes/home /github/taozy_blog/{archetypes,content,data,layouts,static,themes} Watching for config changes in /Volumes/home /github/taozy_blog/config.toml Environment: \u0026quot;development\u0026quot; Serving pages from memory Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender Web Server is available at http://localhost:1313/ (bind address 127.0.0.1) Press Ctrl+C to stop 在浏览器中打开terminal中显示的网址进行预览： http://localhost:1313/\n你可以使用可以编辑md的工具进行内容修改，我习惯用Rstudio打开它进行更改，而且很棒的是，在编辑的过程中，预览网址上的内容也会实时的变更，很方便进行修改。\n 配置Github repository  我配置了两个repos，一个用于托管我blog目录下所有的文件，一个用来托管public文件夹用于博客的显示。\n 第一个repos随意命名  上传blog目录下的文件\n第二个repos必须命名为：your_git_name.github.io，才能够被当作个人的主页  上传public目录下的文件（注意不是public这个文件夹，而是该文件夹下的所有文件），目前还没有生成public文件，不要着急，继续下面的操作。\n在blog目录下执行下面的命令，把theme改成你自己的theme名称，baseUrl换成你自己的github名，执行完会在blog目录下生成一个public目录，将这个目录下的内容上传到your_git_name.github.io仓库中\nhugo --theme=hugo-future-imperfect-slim --baseUrl=\u0026#34;https://taoziyu97.github.io\u0026#34; Start building sites … | EN | FR | PL | PT | DE | ES | ZH-CN | ZH-TW | JA | NL -------------------+----+----+----+----+----+----+-------+-------+----+----- Pages | 11 | 8 | 8 | 8 | 8 | 8 | 8 | 8 | 8 | 8 Paginator pages | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 Non-page files | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 Static files | 21 | 21 | 21 | 21 | 21 | 21 | 21 | 21 | 21 | 21 Processed images | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 Aliases | 3 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 Sitemaps | 2 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 Cleaned | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 Total in 209 ms  总结一下hugo-future-imperfect-slim这个主题的缺点\n 对于内容没有很好的汇总界面 只能一页一页的翻页，不能指定去哪一页 搜索内容的时候不支持中文    设置仓库的GitHub Pages  在仓库主页找到Setting，在Options中对Github Pages进行设置，如果你没有购买域名，那么你就可以在这步直接使用github提供的网址，作为你的博客网页，如果你有自己的域名（比如我从阿里云买了.cn的域名，我就将Custom domain设置为自己的域名）\n 解析域名方法1  打开域名解析，进行解析设置，添加两条记录，主机记录分别为@和www，记录类型为CNAME，记录值都指向github的网址，your_git_name.github.io\n现在打开个人主页试一试效果吧！\n 解析域名方法2（推荐，相对方法1速度更快一些）  Netlify 是一个提供静态资源网络托管的综合平台。参考这个链接内容部署：Netlify部署静态网页\n将Netlify随机生成的域名，在阿里云中进行解析设置。\n  Netlify中解析成功。\n  可以打开啦，访问速度比方法1快一些，另外，我的图是通过图床阅览的，方法2中拜托了github.io域名的限制，相当于把github当作一个储存的空间。\n",
    "ref": "/blog/2021-1-11-build_blog/"
  },{
    "title": "archives",
    "date": "",
    "description": "",
    "body": "",
    "ref": "/archives/"
  },{
    "title": "Contact",
    "date": "",
    "description": "",
    "body": " ",
    "ref": "/contact/"
  }]
